<br><br><h1><a name="ch1">Chapter 1</a></h1>
<h1>Introduction</h1>

<br><h2><a name="sec1.1">1.1</a>&nbsp;&nbsp;&nbsp;&nbsp;Encircling layers</h2>

<p align="justify">An utterance of English is like an onion with encircling layers around internal elements, as pictured in Figure <a href="#figure1.1">1.1</a>.</p>

<p><a name="fig1.1">Figure 1.1: Layers around an innermost element</a></p>

<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="5px" style="border:2px solid;"><tr><td>&nbsp;&nbsp;&nbsp;</td></tr></table>
</td></tr></table>
</td></tr></table>
</td></tr></table>
</td></tr></table>
</td></tr></table>

<p align="justify">The action of <b>parsing</b> amounts to:</p>

<ul>

<li>pealing back layers to reach internal elements</li>

<li>placing everything back together again</li>

</ul>

<p align="justify">An innermost element is either the head word of a phrase layer or the verb of a clause layer.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;While placing everything back together again, we can add labels called <b>annotations</b>. This preserves a record of what was uncovered while pealing back the layers. Subsequently, these labels act as handles that we can query in order to access the structural analysis revealed by parsing.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Furthering the onion analogy, the kind of layering seen in Figure <a href="#figure1.2">1.2</a> occurs when there is coordination, with each conjunct having to conform to whatever is possible at the same particular layer.</p>

<p><a name="fig1.2">Figure 1.2: Parallel layers</a></p>

<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="5px" style="border:2px solid;"><tr><td>&nbsp;&nbsp;&nbsp;</td></tr></table>
</td></tr></table>
</td></tr></table></td><td><table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="10px" style="border:2px solid;"><tr><td>
<table cellpadding="5px" style="border:2px solid;"><tr><td>&nbsp;&nbsp;&nbsp;</td></tr></table>
</td></tr></table>
</td></tr></table>
</td></tr></table>
</td></tr></table>
</td></tr></table>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;In addition to structures that arise from multiple layers, we will observe ripple effects, where what happens at one layer goes on to have consequences for what is possible in other layers.</p>

<br><h2><a name="sec1.2">1.2</a>&nbsp;&nbsp;&nbsp;&nbsp;Phrase structure rules</h2>

<p align="justify">Phrase structure rules are a way to build labelled layers around embedded elements. A phrase structure rule has:</p>

<ul>

<li>a left-hand side that is the label for the layer</li>

<li>a right-hand side made of one, two, or more embedded elements, where an embedded element can be either the label of a layer or a terminal element</li>

</ul>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;For example, the five rules of (<a href="chapter1.html#ex1.1">1.1</a>) involve labelled layers: <tt>vp</tt>, <tt>np_sbj</tt>, and <tt>ip</tt>; and terminal elements: <tt>[smiles]</tt>, <tt>[and]</tt>, and <tt>[he]</tt>.</p>

<dl><dt>(<a name="ex1.1">1.1</a>)</dt><dd>
</dd></dl>

<tt>1.&nbsp;&nbsp;vp&nbsp;--&gt;&nbsp;[smiles].</tt><br>
<tt>2.&nbsp;&nbsp;vp&nbsp;--&gt;&nbsp;vp,&nbsp;[and],&nbsp;vp.</tt><br>
<tt>3.&nbsp;&nbsp;np_sbj&nbsp;--&gt;&nbsp;[he].</tt><br>
<tt>4.&nbsp;&nbsp;ip&nbsp;--&gt;&nbsp;np_sbj,&nbsp;vp.</tt><br>
<tt>5.&nbsp;&nbsp;ip&nbsp;--&gt;&nbsp;ip,&nbsp;[and],&nbsp;ip.</tt><br>

<p align="justify">By following the rules of (<a href="chapter1.html#ex1.1">1.1</a>), we can assemble the structure of (<a href="chapter1.html#ex1.2">1.2</a>): We can start with rule 4 where an <tt>ip</tt> layer can consist of an <tt>np_sbj</tt> layer followed by a <tt>vp</tt> layer. With rule 3 we get to a complete <tt>np_sbj</tt> with the terminal word <tt>[he]</tt>. With rule 2 we get to a <tt>vp</tt>, which is itself made up of a <tt>vp</tt>, followed by an <tt>[and]</tt> word, followed by a <tt>vp</tt>. Finally, with rule 1 we can get to complete <tt>vp</tt> layers with the terminal word <tt>[smiles]</tt>.</p>

<dl><dt>(<a name="ex1.2">1.2</a>)</dt><dd>
</dd></dl>

<table cellpadding="5px" style="border:2px solid;">
<tr><td colspan="2" style="text-align: center; vertical-align: middle;">ip</td></tr>
<tr>
 <td>
   <table cellpadding="5px" style="border:2px solid;">
    <tr><td colspan="1" style="text-align: center; vertical-align: middle;">np_sbj</td></tr>
    <tr>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td><tt>he</tt></td></tr>
       </table>
     </td>
    </tr>
   </table>
 </td>
 <td>
   <table cellpadding="5px" style="border:2px solid;">
    <tr><td colspan="3" style="text-align: center; vertical-align: middle;">vp</td></tr>
    <tr>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td colspan="1" style="text-align: center; vertical-align: middle;">vp</td></tr>
        <tr>
         <td>
           <table cellpadding="5px" style="border:2px solid;">
            <tr><td><tt>smiles</tt></td></tr>
           </table>
         </td>
        </tr>
       </table>
     </td>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td><tt>and</tt></td></tr>
       </table>
     </td>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td colspan="1" style="text-align: center; vertical-align: middle;">vp</td></tr>
        <tr>
         <td>
           <table cellpadding="5px" style="border:2px solid;">
            <tr><td><tt>smiles</tt></td></tr>
           </table>
         </td>
        </tr>
       </table>
     </td>
    </tr>
   </table>
 </td>
</tr>
</table>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;As an alternative to (<a href="chapter1.html#ex1.2">1.2</a>), we might have started with rule 5 of (<a href="chapter1.html#ex1.1">1.1</a>), and thereafter assembled (<a href="chapter1.html#ex1.3">1.3</a>), and so on.</p>

<dl><dt>(<a name="ex1.3">1.3</a>)</dt><dd>
</dd></dl>

<table cellpadding="5px" style="border:2px solid;">
<tr><td colspan="3" style="text-align: center; vertical-align: middle;">ip</td></tr>
<tr>
 <td>
   <table cellpadding="5px" style="border:2px solid;">
    <tr><td colspan="2" style="text-align: center; vertical-align: middle;">ip</td></tr>
    <tr>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td colspan="1" style="text-align: center; vertical-align: middle;">np_sbj</td></tr>
        <tr>
         <td>
           <table cellpadding="5px" style="border:2px solid;">
            <tr><td><tt>he</tt></td></tr>
           </table>
         </td>
        </tr>
       </table>
     </td>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td colspan="1" style="text-align: center; vertical-align: middle;">vp</td></tr>
        <tr>
         <td>
           <table cellpadding="5px" style="border:2px solid;">
            <tr><td><tt>smiles</tt></td></tr>
           </table>
         </td>
        </tr>
       </table>
     </td>
    </tr>
   </table>
 </td>
 <td>
   <table cellpadding="5px" style="border:2px solid;">
    <tr><td><tt>and</tt></td></tr>
   </table>
 </td>
 <td>
   <table cellpadding="5px" style="border:2px solid;">
    <tr><td colspan="2" style="text-align: center; vertical-align: middle;">ip</td></tr>
    <tr>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td colspan="1" style="text-align: center; vertical-align: middle;">np_sbj</td></tr>
        <tr>
         <td>
           <table cellpadding="5px" style="border:2px solid;">
            <tr><td><tt>he</tt></td></tr>
           </table>
         </td>
        </tr>
       </table>
     </td>
     <td>
       <table cellpadding="5px" style="border:2px solid;">
        <tr><td colspan="1" style="text-align: center; vertical-align: middle;">vp</td></tr>
        <tr>
         <td>
           <table cellpadding="5px" style="border:2px solid;">
            <tr><td><tt>smiles</tt></td></tr>
           </table>
         </td>
        </tr>
       </table>
     </td>
    </tr>
   </table>
 </td>
</tr>
</table>

<br><h4>Question:</h4>

<p align="justify">Applying the phrase structure rules of (<a href="chapter1.html#ex1.1">1.1</a>), how many different <tt>ip</tt> structures can be made?</p>

<br><h2><a name="sec1.3">1.3</a>&nbsp;&nbsp;&nbsp;&nbsp;Computer parsing in this book</h2>

<p align="justify">Computer parsing in this book will use Definite Clause Grammar notation (DCG; Pereira and Warren 1980). This is a notation for writing phrase structure grammar rules in which labels for layers can take attributes with values unified by Prolog-style term unification. DCG notation is a feature of virtually all Prolog systems. With DCG notation, we can write phrase structure rules (like (<a href="chapter1.html#ex1.1">1.1</a>) above) and then we have an executable Prolog program.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Prolog and DCGs are discussed in introductory textbooks by Clocksin and Mellish (1981), Pereira and Shieber (1987), Covington (1994), Matthews (1998), Blackburn, Bos and Striegnitz (2006), among others. Shieber (1986) contains discussion of how DCGs relate to other formalisms for encoding natural language grammars, including Categorial Grammar, Lexical Functional Grammar (LFG), Generalized Phrase Structure Grammar (GPSG), and Head-driven Phrase Structure Grammar (HPSG).</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;We will want to include phrase structure grammar rules with left recursion, like rules 2 and 5 of (<a href="chapter1.html#ex1.1">1.1</a>) above. When there is left recursion, avoiding infinite loops from rule calls requires remembering what has already been evaluated. This is possible with a technique called tabling introduced by Swift and Warren (1994). Tabling is a feature of some Prolog systems, notably, the XSB Tabling Prolog system (Swift and Warren 2022). Christiansen and Dahl (2018) discuss the evolution of natural language processing as it relates to Logic Programming, with particular focus on DCGs and tabling.</p>

<br><h2><a name="sec1.4">1.4</a>&nbsp;&nbsp;&nbsp;&nbsp;Structural analysis and labelling in this book</h2>

<p align="justify">The structural analysis and labelling in this book follows the annotation scheme of the Treebank Semantics Parsed Corpus (TSPC; Butler 2022). The TSPC is a corpus of English for general use with hand worked tree analysis for half-a-million words.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The annotation approach is an attempt to consolidate alternative annotation schemes for English:</p>

<ul>

<li>The SUSANNE Corpus and Analytic Scheme (Sampson 1995)</li>

<li>The ICE Parsing Scheme (Nelson, Wallis, and Aarts 2002)</li>

<li>The Penn Treebank Scheme (Marcus, Santorini, and Marcinkiewicz 1993)</li>

<li>The Penn Historical Parsed Corpora Scheme (Santorini 2016)</li>

</ul>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;From the SUSANNE scheme, there is adoption of form and function information, such that the TSPC scheme can be linked most closely to the SUSANNE scheme. The SUSANNE scheme is closely related to the English grammars of Quirk et al.&nbsp;(1972, 1985).</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The ICE Parsing Scheme similarly follows the Quirk et al.&nbsp;grammars. In addition, ICE is notable for its rich range of features. The TSPC annotation supports the ability for many of these features to be automatically derived.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The Penn Historical Corpora scheme, which itself draws on the bracketed approach of the Penn Treebank scheme, has informed the &lsquo;look&rsquo; of the annotation. This includes:</p>

<ul>

<li>the tag labelling: <tt>CP</tt> and <tt>IP</tt> for clause layers; <tt>ADJP</tt>, <tt>ADVP</tt>, <tt>NP</tt>, and <tt>PP</tt> for phrase layers</li>

<li>that label extensions are added to <tt>CP</tt>, <tt>IP</tt>, <tt>ADJP</tt>, <tt>ADVP</tt>, <tt>NP</tt>, and <tt>PP</tt> to indicate functions</li>

<li>the presentation of conjunction structure with <tt>CONJP</tt> layers</li>

</ul>

<p align="justify">However, it should be noted that, labels aside, the tag set of the TSPC scheme is most compatible with the SUSANNE scheme, especially with regards to function marking. Moreover, word class tags closely overlap with the Lancaster word class tagging systems, especially the UCREL CLAWS5 tag set used for the British National Corpus (BNC Consortium 2005).</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The TSPC scheme also contains plenty that is innovative. Most notably, there is normalisation of structure, achieved with intermediate layers at:</p>

<ul>

<li>clause levels (<tt>ILYR</tt>)</li>

<li>noun phrase levels (<tt>NLYR</tt>)</li>

<li>adjective phrase levels (<tt>AJLYR</tt>)</li>

<li>adverb phrase levels (<tt>AVLYR</tt>)</li>

</ul>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Another area of innovation is verb code integration. There are codes to classify catenative verbs, that is, verbs of a verb sequence that are prior to the final main verb, and this type of verb is further supported in the annotation by the layering of clause structure. These catenative codes are relatable to the analysis of catenative verbs in Huddleston and Pullum (2002). The codes for main verbs are from the mnemonic system of the fourth edition of the <i>Oxford Advanced Learner's Dictionary</i> (OALD4; Cowie 1989). Additional codes with very particular distributions are included from Hornby (1975).</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The most innovative aspect of the annotation gives the TSPC its name: It can be fed to the Treebank Semantics evaluation system (Butler 2021). Treebank Semantics processes constituency tree annotations and returns logic-based meaning representations. While the annotation seldom includes indexing, results calculated with Treebank Semantics resolve both inter and intra clause dependencies, including cross sentential anaphoric dependencies.</p>

<br><h2><a name="sec1.5">1.5</a>&nbsp;&nbsp;&nbsp;&nbsp;Representing layered structure</h2>

<p align="justify">When parsing, we will accumulate layers with <tt>node</tt> structures. These structures have the form:</p>

<ul>

<li><tt>node(Label,NodeList)</tt></li>

</ul>

<p align="justify">where <tt>Label</tt> is a label for the layer and <tt>NodeList</tt> is a list of <tt>node</tt> structures that are the content for the layer.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;In Prolog, lists are written with square bracket notation:</p>

<ul>

<li><tt>[a1, ..., aN]</tt></li>

</ul>

<p align="justify">where <tt>a1</tt> through to <tt>aN</tt> are the list items. The list that contains no items (<tt>[]</tt>) is the empty list. A terminal layer of structure has the form:</p>

<ul>

<li><tt>node(Word,[])</tt></li>

</ul>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;With this background, consider (<a href="chapter1.html#ex1.4">1.4</a>) as an example of encircling layers gathered with <tt>node</tt> structures.</p>

<dl><dt>(<a name="ex1.4">1.4</a>)</dt><dd>
</dd></dl>

<tt>node('IP-MAT',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('NP-SBJ',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('PRO',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('He',[])])]),</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node('ILYR',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('ILYR',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('VBP;~I',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('smiles',[])])]),</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node('CONJP',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('CONJ',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('and',[])]),</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node('ILYR',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('VBP;~I',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('smiles',[])])])])]),</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node('PUNC',</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[node('.',[])])])</tt><br>

<p align="justify">We will more typically present <tt>node</tt> structure as labelled bracketed structure, as in (<a href="chapter1.html#ex1.5">1.5</a>).</p>

<dl><dt>(<a name="ex1.5">1.5</a>)</dt><dd>
</dd></dl>

<tt>(IP-MAT&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;He))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ILYR&nbsp;(ILYR&nbsp;(VBP;~I&nbsp;smiles))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CONJP&nbsp;(CONJ&nbsp;and)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ILYR&nbsp;(VBP;~I&nbsp;smiles))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;.))</tt><br>

<br><h2><a name="sec1.6">1.6</a>&nbsp;&nbsp;&nbsp;&nbsp;Orientation</h2>

<p align="justify">We will proceed as follows. In the remainder of this chapter, section <a href="chapter1.html#sec1.7">1.7</a> introduces rules for identifying sentences, and section <a href="chapter1.html#sec1.8">1.8</a> introduces rules for sentence fragments and utterances. This will demonstrate writing DCG rules with attributes for collecting layered structure and passing on ripple information. This will also demonstrate using the Prolog system to query English word input.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Subsequent chapters define rules to build up a wide coverage of consequences from word input. This starts in chapter <a href="chapter2.html#ch2">2</a> with an inventory of the kinds of words there are in English. Once we have a handle on the range of words, we will want to start placing words together to create phrases, and this is the goal of chapter <a href="chapter3.html#ch3">3</a>. Chapter <a href="chapter4.html#ch4">4</a> establishes what verbs require to be present in the clause based on their given verb code. With access to phrases and verb words with their selection requirements, we will have content for clause layers. Establishing what is possible at the clause layer is the goal of chapter <a href="chapter5.html#ch5">5</a>. Chapter <a href="chapter6.html#ch6">6</a> builds on all the preceding chapters by integrating clause subordination. Chapter <a href="chapter7.html#ch7">7</a> gives closing remarks.</p>

<br><h2><a name="sec1.7">1.7</a>&nbsp;&nbsp;&nbsp;&nbsp;Sentences</h2>

<p align="justify">The Prolog code of (<a href="chapter1.html#ex1.6">1.6</a>) gives phrase structure rules to initiate finding layered content to say there is a sentence.</p>

<dl><dt>(<a name="ex1.6">1.6</a>)</dt><dd>
</dd></dl>

<tt>sentence([node('IP-MAT',IL)|L],L)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;clause_top_layer(basic_clause,[],IL,IL1),</tt><br>
<tt>&nbsp;&nbsp;punc(final,IL1,[]).</tt><br>
<tt>sentence([node('IP-IMP',IL)|L],L)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;clause_top_layer(imperative_clause,[],IL,IL1),</tt><br>
<tt>&nbsp;&nbsp;punc(final,IL1,[]).</tt><br>
<tt>sentence([node('CP-QUE',[node('IP-SUB',IL),PU])|L],L)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;clause_top_layer(matrix_interrogative,[],IL,[]),</tt><br>
<tt>&nbsp;&nbsp;punc(final_question,[PU],[]).</tt><br>
<tt>sentence([node('IP-MAT',IL)|L],L)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;clause_top_layer(basic_clause,[],IL,IL2),</tt><br>
<tt>&nbsp;&nbsp;punc(non_final,IL2,[node('PRN',[node('CP-QUE',[node('IP-SUB',TL)])])|IL1]),</tt><br>
<tt>&nbsp;&nbsp;clause_top_layer(tag_question,[],TL,[]),</tt><br>
<tt>&nbsp;&nbsp;punc(final_question,IL1,[]).</tt><br>

<p align="justify">The first <tt>sentence</tt> rule of (<a href="chapter1.html#ex1.6">1.6</a>) will create a <tt>node</tt> structure with <tt>'IP-MAT'</tt> (statement matrix clause) as its node label and a list <tt>IPL</tt> that will have accumulated the layer content. <tt>IP</tt> is an abbreviation for Inflectional Phrase, which is another way to say &lsquo;clause&rsquo;. To succeed, rule 1 needs content to parse that involves a list of items where all but the last item satisfies one of the <tt>clause_top_layer</tt> phrase structure rules (see section <a href="chapter5.html#sec5.2">5.2</a>), and where the last list item is an instance of final punctuation (see section <a href="chapter2.html#sec2.12">2.12</a>).</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;In (<a href="chapter1.html#ex1.7">1.7</a>), two Prolog calls are made. The first call has <tt>tphrase_set_string</tt> to store a list of word items to parse. Let's call this the <b>word list</b>. The second call has <tt>parse</tt> to question whether the stored word list has content to satisfy a call of <tt>sentence</tt>. Note that the parameter of <tt>sentence</tt> for accumulating parse structure is hidden internally to the <tt>parse</tt> call. If <tt>parse</tt> succeeds, then all parse results are presented as bracketed tree output.</p>

<dl><dt>(<a name="ex1.7">1.7</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('PRO','He'), w('VBP',';~I','smiles'), w('PUNC','.')]),&nbsp;parse(sentence).</tt><br>


<tt>(IP-MAT&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;He))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBP;~I&nbsp;smiles)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;.))</tt><br>


<tt>yes</tt><br>

<p align="justify">The output from (<a href="chapter1.html#ex1.7">1.7</a>) shows the return of a structure with <tt>IP-MAT</tt> as the topmost node, from which it follows that rule 1 of (<a href="chapter1.html#ex1.6">1.6</a>) completed successfully.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Now consider (<a href="chapter1.html#ex1.8">1.8</a>).</p>

<dl><dt>(<a name="ex1.8">1.8</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('VB',';~I','Smile'), w('PUNC','.')]),&nbsp;parse(sentence).</tt><br>


<tt>(IP-IMP&nbsp;(VB;~I&nbsp;Smile)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;.))</tt><br>


<tt>yes</tt><br>

<p align="justify">The output from (<a href="chapter1.html#ex1.8">1.8</a>) shows the return of a structure with <tt>IP-IMP</tt> (imperative clause) as the topmost node: Rule 1 of (<a href="chapter1.html#ex1.6">1.6</a>) will fail, but rule 2 succeeds. Rule 2 is very similar to rule 1: Both call <tt>clause_top_layer</tt> phrase structure rules, but they do so with different settings for the clause type: <tt>basic_clause</tt> for rule 1, and <tt>imperative_clause</tt> for rule 2.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;An imperative clause should have no subject and a verb with imperative form, so a verb with <tt>VB</tt> word class information as in (<a href="chapter1.html#ex1.8">1.8</a>). If we try (<a href="chapter1.html#ex1.9">1.9</a>), which is unsuitable as a statement sentence because of the lack of content for a subject but then also unsuitable as an imperative sentence because the verb has <tt>VBP</tt> (present tense) word class, then there can be no parse result, as (<a href="chapter1.html#ex1.9">1.9</a>) shows.</p>

<dl><dt>(<a name="ex1.9">1.9</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('VBP',';~I','Smiles'), w('PUNC','.')]),&nbsp;parse(sentence).</tt><br>


<tt>no</tt><br>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;As a further example of checking if there is word list content for a sentence, consider (<a href="chapter1.html#ex1.10">1.10</a>).</p>

<dl><dt>(<a name="ex1.10">1.10</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('DOD','','Did'), w('PRO','he'), w('VB',';~I','smile'), w('PUNC','?')]),&nbsp;parse(sentence).</tt><br>


<tt>(CP-QUE&nbsp;(IP-SUB&nbsp;(DOD&nbsp;Did)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;he))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB;~I&nbsp;smile))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;?))</tt><br>


<tt>yes</tt><br>

<p align="justify">The output from (<a href="chapter1.html#ex1.10">1.10</a>) shows the return of a structure with <tt>CP-QUE</tt> (interrogative clause) as the topmost node. This is achieved with rule 3 of (<a href="chapter1.html#ex1.6">1.6</a>), which expects the word list to provide content for the success of a <tt>clause_top_layer</tt> rule with the clause type parameter set to <tt>matrix_interrogative</tt>.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;As yet another example of checking word list content for being a sentence, consider (<a href="chapter1.html#ex1.11">1.11</a>).</p>

<dl><dt>(<a name="ex1.11">1.11</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('PRO','He'), w('MD','might'), w('VB',';~I','smile'), w('PUNC',','), w('MD','might'), w('NEG;_clitic_','n&lt;apos&gt;t'), w('PRO','he'), w('PUNC','?')]),&nbsp;parse(sentence).</tt><br>


<tt>(IP-MAT&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;He))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;might)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB;~I&nbsp;smile)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;,)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PRN&nbsp;(CP-QUE&nbsp;(IP-SUB&nbsp;(MD&nbsp;might)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NEG;_clitic_&nbsp;n&lt;apos&gt;t)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;he)))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;?))</tt><br>


<tt>yes</tt><br>

<p align="justify">The output from (<a href="chapter1.html#ex1.11">1.11</a>) shows the return of a sentence ending in a tag question, which is achieved with rule 4 of (<a href="chapter1.html#ex1.6">1.6</a>).</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;To sum up, this section has shown how to query whether a word list contains content for an English sentence. With success, returned structure tells us about the kind of sentence: statement matrix sentence (<tt>IP-MAT</tt>), imperative sentence (<tt>IP-IMP</tt>), or interrogative sentence (<tt>CP-QUE</tt>).</p>

<br><h4>Question:</h4>

<p align="justify">Why do the failure and success results of (<a href="chapter1.html#ex1.12">1.12</a>) &ndash; (<a href="chapter1.html#ex1.14">1.14</a>) obtain?</p>

<dl><dt>(<a name="ex1.12">1.12</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('DOD','','Did'), w('PRO','he'), w('VB',';~I','smile'), w('PUNC','.')]),&nbsp;parse(sentence).</tt><br>


<tt>no</tt><br>

<dl><dt>(<a name="ex1.13">1.13</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('PRO','he'), w('DOD','','did'), w('VB',';~I','smile'), w('PUNC','.')]),&nbsp;parse(sentence).</tt><br>


<tt>(IP-MAT&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;he))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(DOD&nbsp;did)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB;~I&nbsp;smile)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;.))</tt><br>


<tt>yes</tt><br>

<dl><dt>(<a name="ex1.14">1.14</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('PRO','he'), w('DOD','','did'), w('VB',';~I','smile'), w('PUNC','?')]),&nbsp;parse(sentence).</tt><br>


<tt>no</tt><br>

<br><h2><a name="sec1.8">1.8</a>&nbsp;&nbsp;&nbsp;&nbsp;Sentence fragments and utterances</h2>

<p align="justify">An overall utterance can consist of a single sentence or sentence fragment, or multiple instances of sentences and/or sentence fragments, and might itself form part of an embedding as reported speech.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Rule (<a href="chapter1.html#ex1.15">1.15</a>) identifies a sentence fragment as content for a fragment layer followed by sentence final punctuation.</p>

<dl><dt>(<a name="ex1.15">1.15</a>)</dt><dd>
</dd></dl>

<tt>fragment([node('FRAG',FL)|L],L)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;fragment_layer(FL,FL1),</tt><br>
<tt>&nbsp;&nbsp;punc(final,FL1,[]).</tt><br>

<p align="justify">Fragment layer content is found with calls of (<a href="chapter1.html#ex1.16">1.16</a>) that detect:</p>

<ul>

<li>[rule 1] a noun phrase (see section <a href="chapter3.html#sec3.2">3.2</a>)</li>

<li>[rule 2] an adjective phrase (see section <a href="chapter3.html#sec3.4">3.4</a>)</li>

<li>[rule 3] an adverbial (see section <a href="chapter2.html#sec2.10">2.10</a>)</li>

</ul>

<dl><dt>(<a name="ex1.16">1.16</a>)</dt><dd>
</dd></dl>

<tt>fragment_layer(L,L0)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;noun_phrase('',_,L,L0).</tt><br>
<tt>fragment_layer(L,L0)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;adjective_phrase('',_,L,L0).</tt><br>
<tt>fragment_layer(L,L0)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;adverbial(L,L0).</tt><br>

<p align="justify">For rule 3 of (<a href="chapter1.html#ex1.16">1.16</a>), an adverbial can be:</p>

<ul>

<li>a clause level word (but not a verb word, negation, or infinitival <i>to</i>)</li>

<li>an adverb phrase</li>

<li>a preposition phrase</li>

<li>a clause introduced by subordinate conjunction</li>

</ul>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;With the rules to identify sentence fragments, and the sentence rules from section <a href="chapter1.html#sec1.7">1.7</a>, rule (<a href="chapter1.html#ex1.17">1.17</a>) calls the rules of (<a href="chapter1.html#ex1.18">1.18</a>) to recursively find the content of sentences and/or sentence fragments [rules 3 and 4 of (<a href="chapter1.html#ex1.18">1.18</a>)]. The recursion ends by picking up a final sentence or sentence fragment (which could be the only utterance element) [rules 1 and 2 of (<a href="chapter1.html#ex1.18">1.18</a>)].</p>

<dl><dt>(<a name="ex1.17">1.17</a>)</dt><dd>
</dd></dl>

<tt>utterance(Ext,[node(Label,UL)|L],L)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;utterance_collect(UL,[]),</tt><br>
<tt>&nbsp;&nbsp;{</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;atom_concat('utterance',Ext,Label)</tt><br>
<tt>&nbsp;&nbsp;}.</tt><br>

<dl><dt>(<a name="ex1.18">1.18</a>)</dt><dd>
</dd></dl>

<tt>utterance_collect(L,L0)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;sentence(L,L0).</tt><br>
<tt>utterance_collect(L,L0)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;fragment(L,L0).</tt><br>
<tt>utterance_collect(L,L0)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;sentence(L,L1),</tt><br>
<tt>&nbsp;&nbsp;utterance_collect(L1,L0).</tt><br>
<tt>utterance_collect(L,L0)&nbsp;--&gt;</tt><br>
<tt>&nbsp;&nbsp;fragment(L,L1),</tt><br>
<tt>&nbsp;&nbsp;utterance_collect(L1,L0).</tt><br>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Example (<a href="chapter1.html#ex1.19">1.19</a>) illustrates the parse of an utterance that has an initial imperative sentence and ends with a sentence fragment that has a noun phrase as content for its fragment layer.</p>

<dl><dt>(<a name="ex1.19">1.19</a>)</dt><dd>
</dd></dl>

<tt>|&nbsp;?-&nbsp;tphrase_set_string([w('VB',';~I','Beware'), w('PUNC','!'), w('PRO;_genm_','His'), w('ADJ','flashing'), w('NS','eyes'), w('PUNC','!')]),&nbsp;parse(utterance('')).</tt><br>


<tt>(utterance&nbsp;(IP-IMP&nbsp;(VB;~I&nbsp;Beware)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;!))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(FRAG&nbsp;(NP&nbsp;(NP-GENV&nbsp;(PRO;_genm_&nbsp;His))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADJP&nbsp;(ADJ&nbsp;flashing))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NS&nbsp;eyes))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PUNC&nbsp;!)))</tt><br>


<tt>yes</tt><br>

<br>
<br>
<br>
