<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset=utf-8>
  <meta name="robots" content="noindex,nofollow">
  <meta name="Content-Style" content="text/css">
  <title>An Unofficial Tsurgeon Guide</title>
  <style>
body {
        background-color: #FFFFFF;
        color: #111111;
        margin: 15px auto;
        padding: 0 10px;
}
@media (min-width: 800px) {
        body {
                max-width: 85%;
        }
}
  </style>
</head>
<body>

<br>
<br>
<center><h1>An Unofficial Tsurgeon Guide</h1></center>
<center><h2>Alastair Butler</h2></center>
<center><h3>Hirosaki University</h3></center>

<br>
<br>

<br>
<center><h3>Abstract</h3></center>
<p align="justify">
The Tsurgeon program (Levy and Andrew 2006) is a software tool for manipulating bracketed (Penn) style trees. This guide provides an introduction to the tool with examples of basic and advanced use. This guide sources explanatory detail from README-tsurgeon.txt, which is part of the Tregex distribution that includes Tsurgeon. In discussing Tregex patterns, explanatory detail is also sourced from the TGrep2 manual that accompanies the TGrep2 (Rohde 2005) search tool.
</p>
<br>
<br>

<br>
<h2><a name="sec1">1</a>&nbsp;&nbsp;&nbsp;Introduction</h2>

<p align="justify">The Tsurgeon program (Levy and Andrew 2006) is a software tool for manipulating bracketed (Penn) style trees. The tool is available from <tt><a href="http:&sol;&sol;nlp.stanford.edu&sol;software&sol;tregex.shtml">http:&sol;&sol;nlp.stanford.edu&sol;software&sol;tregex.shtml</a></tt>. It works by taking trees specified with round bracketed notation as input, and with each input tree it tries to match one or more Tregex patterns to the tree, and for each successful pattern match it continues to apply surgical actions to the tree until the activating match no longer holds true. After all pairings of a Tregex pattern with Tsurgeon actions have been applied to each input tree, resulting trees are printed.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;This guide is structured as follows. Section <a href="#sec2">2</a> details the required format for Tsurgeon scripts that consist of one or perhaps many pairings of a Tregex pattern with Tsurgeon action(s). Section <a href="#sec3">3</a> sketches the workings of a full example. Section <a href="#sec4">4</a> details Tregex patterns. Section <a href="#sec5">5</a> demonstrates in turn each of the available Tsurgeon actions. Section <a href="#sec6">6</a> adds the possibility of using macros with the macro processor <tt>m4</tt>. Section <a href="#sec7">7</a> presents an extended example. Section <a href="#sec8">8</a> notes a way to run Tsurgeon scripts from the command prompt.</p>

<br>
<h2><a name="sec2">2</a>&nbsp;&nbsp;&nbsp;Tsurgeon script format</h2>

<p align="justify">Tsurgeon scripts are a combination of a Tregex pattern to match input trees and a series of Tsurgeon actions to perform on matched trees. The Tsurgeon program is unforgiving about the required line formatting of a script, because this is how Tregex patterns are distinguished from Tsurgeon actions. In particular:</p>
<ul>
<li>The Tregex pattern should form one or more lines without intervening blank lines that is either the first uncommented text of the script or has at least one blank line to separate off any prior pairing of Tregex pattern with Tsurgeon action(s).</li>
<li>The Tregex pattern must then be followed by a single blank line, while there must be one or more subsequent lines without intervening blank lines that consist of Tsurgeon actions, with one Tsurgeon action per line.</li>
<li>A following blank line allows for the start of a new pairing of a Tregex pattern with Tsurgeon action(s).</li>
<li>The character <tt>%</tt> introduces a comment that extends to the end of the line. Non-comment uses of <tt>%</tt> must be escaped as <tt>&#92;%</tt>.</li>
</ul>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The following is an example of a correctly formatted script:</p>

<h4>Example 1</h4>

<hr/>
<tt>&nbsp;&nbsp;!&sol;^(WORD$|&#92;*)&sol;=x&nbsp;!&lt;&nbsp;__&nbsp;!&gt;&nbsp;&sol;^PU&sol;</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;x&nbsp;WORD</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;WORD=x</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;delete&nbsp;x</tt><br>

<hr/>

<br>
<h2><a name="sec3">3</a>&nbsp;&nbsp;&nbsp;Pattern-action based programming</h2>

<p align="justify">When Tsurgeon runs your script, it will read in each tree of the input, one after the other. Each time it reads in a tree, it will see if your Tregex pattern finds a match. If it does, then it will keep performing the Tsurgeon action(s) for the active Tregex pattern, stopping only when the Tregex pattern no longer matches. You can define as many pairings of a Tregex pattern with Tsurgeon action(s) as you like. If more than one pairing occurs, each pairing is performed in the order they appear in your script. So Tsurgeon is, in effect, three nested loops: from the input go over the trees; for each tree go over the patterns and, if a Tregex pattern matches, keep going over the Tsurgeon action(s), until there is no longer a match for the Tregex pattern.</p>

<h3><a name="sec3.1">3.1</a>&nbsp;&nbsp;&nbsp;Program behaviour</h3>

<p align="justify">To see program behaviour, consider Example 1 of section <a href="#sec2">2</a>. The first line, repeated as (<a href="#ex1">1</a>), specifies with a Tregex pattern the initial tree structure looked for.</p>

<dl>
  <dt>(<a name="ex1">1</a>)</dt><dd></dd>
</dl>
<tt>!&sol;^(WORD$|&#92;*)&sol;=x&nbsp;!&lt;&nbsp;__&nbsp;!&gt;&nbsp;&sol;^PU&sol;</tt><br>

<p align="justify">See section <a href="#sec4">4</a> for details about Tregex patterns. Here it is enough to know that (<a href="#ex1">1</a>) finds trees when there is a node such that it:</p>
<dl>
<dt>1.</dt><dd>is not <tt>WORD</tt>,</dd>
<dt>2.</dt><dd>does not start with &lsquo;<tt>*</tt>&rsquo;,</dd>
<dt>3.</dt><dd>does not dominate any other node, and</dd>
<dt>4.</dt><dd>is not dominated by a node that starts with <tt>PU</tt>.</dd>
</dl>

<p align="justify">For example, tree (<a href="#ex2">2</a>) is matched:</p>

<dl>
  <dt>(<a name="ex2">2</a>)</dt><dd></dd>
</dl>
<tt>(IP-IMP&nbsp;(NP-SBJ&nbsp;*speaker+hearer*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Nodes of a found tree are named when &lsquo;<tt>=<name></tt>&rsquo; is appended to the expression for finding a node label. That name can be referred to by subsequent Tsurgeon actions triggered by the same match. With the first line pattern, found nodes can be referred to with &lsquo;<tt>x</tt>&rsquo;.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The Tsurgeon action for the first Tregex pattern, repeated as (<a href="#ex3">3</a>), is given on the third line of the script, which follows an empty line.</p>

<dl>
  <dt>(<a name="ex3">3</a>)</dt><dd></dd>
</dl>
<tt>relabel&nbsp;x&nbsp;WORD</tt><br>

<p align="justify">This tree transforming action brings about a relabelling to <tt>WORD</tt> of the node referred to with &lsquo;<tt>x</tt>&rsquo; following the match with pattern (<a href="#ex1">1</a>). The combination of this initial Tregex pattern and Tsurgeon action is to transform the example matched tree (<a href="#ex2">2</a>) into (<a href="#ex4">4</a>).</p>

<dl>
  <dt>(<a name="ex4">4</a>)</dt><dd></dd>
</dl>
<tt>(IP-IMP&nbsp;(NP-SBJ&nbsp;*speaker+hearer*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;WORD)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;WORD)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">Note how (<a href="#ex4">4</a>) is reached by action (<a href="#ex3">3</a>) being applied twice, after which pattern (<a href="#ex1">1</a>) is no longer able to find a match.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Following action (<a href="#ex3">3</a>), there are then two empty lines in Example 1, making line 6 that follows a new pattern to find trees that contain a node name that matches the simple string pattern <tt>WORD</tt> which can thereafter be referred to with &lsquo;<tt>x</tt>&rsquo;. There is then another empty line, making line 8 that follows a Tsurgeon action to remove the node referred to with &lsquo;<tt>x</tt>&rsquo;, resulting in (<a href="#ex5">5</a>) as the overall output from running the program of Example 1 on the input tree (<a href="#ex2">2</a>).</p>

<dl>
  <dt>(<a name="ex5">5</a>)</dt><dd></dd>
</dl>
<tt>(IP-IMP&nbsp;(NP-SBJ&nbsp;*speaker+hearer*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VB</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MD</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<h3><a name="sec3.2">3.2</a>&nbsp;&nbsp;&nbsp;Avoiding infinite loops</h3>

<p align="justify">By first changing all words to <tt>WORD</tt> and then removing all <tt>WORD</tt> instances, Example 1 demonstrates how the match of a Tregex pattern with Tsurgeon action(s) will apply repeatedly until no further match is possible. Attractive consequences of this runtime behaviour are that trees may match Tregex patterns multiple times, and earlier Tsurgeon actions may enable subsequent matches of the active Tregex pattern for further Tsurgeon actions. But with such power there has to come responsibility, with extra special care needing to be made to avoid accidentally starting an infinite loop. For example, consider missing the initial &lsquo;<tt>!</tt>&rsquo; (negation) sign from the first pattern of Example 1, to give:</p>

<h4>Example 2</h4>

<hr/>
<tt>&nbsp;&nbsp;&sol;^(WORD$|&#92;*)&sol;=x&nbsp;!&lt;&nbsp;__&nbsp;!&gt;&nbsp;&sol;^PU&sol;</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;x&nbsp;WORD</tt><br>

<hr/>

<p align="justify">The changed pattern will find terminal nodes that are not dominated by nodes beginning with <tt>PU</tt>, and that are either <tt>WORD</tt> or character strings that begin with &lsquo;<tt>*</tt>&rsquo;. This pattern will match the same tree (<a href="#ex2">2</a>) as seen with the discussion of Example 1, while now it is the occurrence of <tt>*speaker+hearer*</tt> that is changed to <tt>WORD</tt>, resulting in (<a href="#ex6">6</a>).</p>

<dl>
  <dt>(<a name="ex6">6</a>)</dt><dd></dd>
</dl>
<tt>(IP-IMP&nbsp;(NP-SBJ&nbsp;WORD)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">The transformed tree of (<a href="#ex6">6</a>) continues to match the triggering pattern because of the presence of <tt>WORD</tt> resulting in the replacement of <tt>WORD</tt> for <tt>WORD</tt>, which continues to match, and so the loop of changing <tt>WORD</tt> into <tt>WORD</tt> continues with no termination prospect.</p>

<br>
<h2><a name="sec4">4</a>&nbsp;&nbsp;&nbsp;Tregex patterns</h2>

<p align="justify">Patterns are expressed with the Tregex pattern language. This closely resembles the query language of TGrep (Pito 1994), and includes extensions from TGrep2 (Rohde 2005). TGrep was the original tree-matching program that came with the Penn Treebank. TGrep2 is a reimplementation with extensions, available at <tt><a href="http:&sol;&sol;tedlab.mit.edu&sol;~dr&sol;TGrep2">http:&sol;&sol;tedlab.mit.edu&sol;~dr&sol;TGrep2&sol;</a></tt>. Notably:</p>
<ul>
<li>Nodes of searched trees are matched either with simple character strings, or OR'd character strings, or regular expressions (see section <a href="#sec4.1">4.1</a>).</li>
<li>Relationships combine node expressions (see section <a href="#sec4.2">4.2</a>).</li>
<li>Tregex patterns also allow Boolean expressions of relationships to form complex relationships (see section <a href="#sec4.3">4.3</a>).</li>
<li>Nodes can be assigned labels and may be referred to elsewhere in the pattern by those labels (see section <a href="#sec4.4">4.4</a>).</li>
<li>Names can be assigned to matching groups of the regular expressions used to match nodes (see section <a href="#sec4.5">4.5</a>).</li>
<li>Patterns can be broken into multiple segments (see section <a href="#sec4.6">4.6</a>).</li>
</ul>

<h3><a name="sec4.1">4.1</a>&nbsp;&nbsp;&nbsp;Specifying nodes in a Tregex pattern</h3>

<p align="justify">Single tree nodes are matched as follows:</p>
<ul>
<li>A wildcard, specified by two underscores (&lsquo;<tt>__</tt>&rsquo;), matches any node.</li>
<li>A simple character string, such as <tt>IP-ADV</tt>, <tt>NP</tt>, <tt>ADV</tt>, <tt>Taro</tt>, etc., matches if it is the full content of the matched node.</li>
<li>A pattern can be built from simple character strings separated by pipes (&lsquo;<tt>|</tt>&rsquo;) with no spaces. Such a pattern will match a node if any of its components match the node's full content. For example, <tt>NP|PP</tt> will identify <tt>NP</tt> or <tt>PP</tt> nodes.</li>
<li>A regular expression, indicated by surrounding slashes (&lsquo;<tt>&sol;</tt>&rsquo;), such as <tt>&sol;^NP&#92;b&sol;</tt>, can be used as a description to match nodes which possibly differ in their full content.</li>
<li>If a simple character string or regular expression begins with &lsquo;<tt>!</tt>&rsquo;, the matching process will be complemented. That is, matches will turn into non-matches, and vice-versa. For example, <tt>!VB</tt> will match all nodes that are not <tt>VB</tt>, and <tt>!&sol;^I&sol;</tt> will match any node that does not start with <tt>I</tt>.</li>
</ul>

<h4><a name="sec4.1.1">4.1.1</a>&nbsp;&nbsp;&nbsp;Tregex regular expressions</h4>

<p align="justify">Tregex regular expressions follow Java conventions for expressing regular expressions. For details, see e.g.: <tt><a href="https:&sol;&sol;docs.oracle.com&sol;javase&sol;7&sol;docs&sol;api&sol;java&sol;util&sol;regex&sol;Pattern.html">https:&sol;&sol;docs.oracle.com&sol;javase&sol;7&sol;docs&sol;api&sol;java&sol;util&sol;regex&sol;Pattern.html</a></tt>.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Specified as a string, a regular expression matches a node if there is a part of the node that is matched. For example, <tt>&sol;[PCV]P&sol;</tt> matches <tt>PP</tt>, <tt>CP-THT</tt>, <tt>ADVP</tt>, etc.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The caret (&lsquo;<tt>^</tt>&rsquo;) anchors the regular expression to the beginning of a matched node. So, <tt>&sol;^[PCV]P&sol;</tt> will not match <tt>ADVP</tt> but will match <tt>PP</tt> and <tt>CP-THT</tt>. A dollar sign (&lsquo;<tt>&dollar;</tt>&rsquo;) as the last character will anchor the regular expression to the end of a matched node. For example, <tt>&sol;PRD&dollar;&sol;</tt> will not match <tt>NP-PRD2</tt> but will match <tt>NP-PRD</tt>. Use of both the caret and dollar-sign in <tt>&sol;^[NP]P&dollar;&sol;</tt> constrains the match to only <tt>NP</tt> and <tt>PP</tt>. A regular expression can also be constrained with &lsquo;<tt>&#92;b</tt>&rsquo; to mark a word boundary. Thus, <tt>&sol;^NP&#92;b&sol;</tt> will match <tt>NP</tt> and <tt>NP-PRD</tt> but will not match <tt>NPR</tt>.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;By default, regular expressions are case sensitive and so <tt>&sol;^The&dollar;&sol;</tt> and <tt>&sol;^the&dollar;&sol;</tt> match different nodes. Case insensitivity can be turned on by including the flag <tt>(?i)</tt> and then everything to the right will be case-insensitive, e.g., <tt>&sol;^(?i)the&dollar;&sol;</tt> matches: <tt>THE</tt>, <tt>The</tt>, <tt>the</tt>, <tt>tHE</tt>, etc. Having turned case insensitivity on, it is possible to turn case insensitivity off with the flag <tt>(?-i)</tt> to become case sensitive again, e.g., <tt>&sol;^t(?i)h(?-i)e&dollar;&sol;</tt> matches: <tt>the</tt>, <tt>tHe</tt>. It is also possible to limit the region of case insensitivity to a given variable group (see section <a href="#sec4.5">4.5</a>), e.g., while <tt>&sol;^t(h)e&dollar;&sol;</tt> matches: <tt>the</tt>, <tt>&sol;^t(?i:h)e&dollar;&sol;</tt> matches: <tt>the</tt>, <tt>tHe</tt>.</p>

<h3><a name="sec4.2">4.2</a>&nbsp;&nbsp;&nbsp;Relationships between nodes</h3>

<p align="justify">Relationships define connections between nodes. There is a complete pairing of relationships with counterparts, allowing for flexibility when constructing complex relationships (see section <a href="#sec4.3">4.3</a>). Notable relationships can be pictured as in Figure <a href="#fig1">1</a>.</p>

<p><a name="fig1">Figure 1: Notable relationships between nodes</a></p>

<img src="notable.png" alt="Notable relationships between nodes" height="600">

<p align="justify">The relationships pictured in Figure <a href="#fig1">1</a> are described in (<a href="#ex7">7</a>).</p>

<dl>
  <dt>(<a name="ex7">7</a>)</dt><dd></dd>
</dl>
<tt>&nbsp;&nbsp;A&nbsp;&gt;&gt;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;dominated&nbsp;by&nbsp;(is&nbsp;a&nbsp;descendant&nbsp;of)&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;,,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;follows&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;immediately&nbsp;follows&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&gt;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;immediately&nbsp;dominated&nbsp;by&nbsp;(is&nbsp;the&nbsp;child&nbsp;of)&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;.&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;immediately&nbsp;precedes&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;..&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;precedes&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;$,,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;a&nbsp;sister&nbsp;of&nbsp;and&nbsp;follows&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;$,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;a&nbsp;sister&nbsp;of&nbsp;and&nbsp;immediately&nbsp;follows&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;==&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;and&nbsp;B&nbsp;are&nbsp;the&nbsp;same&nbsp;node</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;$&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;a&nbsp;sister&nbsp;of&nbsp;and&nbsp;not&nbsp;equal&nbsp;to&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;$.&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;a&nbsp;sister&nbsp;of&nbsp;and&nbsp;immediately&nbsp;precedes&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;$..&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;a&nbsp;sister&nbsp;of&nbsp;and&nbsp;precedes&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;i&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;is&nbsp;the&nbsp;ith&nbsp;child&nbsp;of&nbsp;A&nbsp;(i&nbsp;&gt;&nbsp;0);&nbsp;also&nbsp;expressed&nbsp;as&nbsp;B&nbsp;&gt;i&nbsp;A</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;-i&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;is&nbsp;the&nbsp;ith-to-last&nbsp;child&nbsp;of&nbsp;A&nbsp;(i&nbsp;&gt;&nbsp;0);&nbsp;also&nbsp;expressed&nbsp;as&nbsp;A&nbsp;&gt;-i&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;immediately&nbsp;dominates&nbsp;(is&nbsp;the&nbsp;parent&nbsp;of)&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;&lt;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;dominates&nbsp;(is&nbsp;an&nbsp;ancestor&nbsp;of)&nbsp;B</tt><br>

<h4><a name="sec4.2.1">4.2.1</a>&nbsp;&nbsp;&nbsp;The <tt>i</tt>-th child relationships</h4>

<p align="justify">To specify the exact child position which a node must (or must not) occupy, use the <tt>i</tt>-th child relationships (<tt>&lt;i</tt>, <tt>&lt;-i</tt>, <tt>!&lt;i</tt>, and <tt>!&lt;-i</tt>; also expressed with <tt>&gt;i</tt>, <tt>&gt;-i</tt>, <tt>!&gt;i</tt>, and <tt>!&gt;-i</tt>). In these relationships, <tt>i</tt> represents a number indicating which child &lsquo;slot&rsquo; is to be considered. Positive numbers are counts from the left edge, while negative numbers are counts from the right edge. For example, (<a href="#ex8">8</a>) finds instances of <tt>NP</tt> where the second child is a <tt>PP</tt>.</p>

<dl>
  <dt>(<a name="ex8">8</a>)</dt><dd><tt>NP &lt;2 PP</tt></dd>
</dl>

<p align="justify">Pattern (<a href="#ex9">9</a>) finds instances of <tt>NP</tt> where the last child is a <tt>PP</tt>.</p>

<dl>
  <dt>(<a name="ex9">9</a>)</dt><dd><tt>NP &lt;-1 PP</tt></dd>
</dl>

<p align="justify">Pattern (<a href="#ex10">10</a>) finds instances of <tt>NP</tt> which have less than three children. That is, every <tt>NP</tt> which has three or more children will have <i>something</i> as its third child to make matching with (<a href="#ex10">10</a>) fail.</p>

<dl>
  <dt>(<a name="ex10">10</a>)</dt><dd><tt>NP !&lt;3 __</tt></dd>
</dl>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;To select nodes with specific numbers of children you can use a positive and negative <tt>i</tt>-th child relationship. For example, to find <tt>NP</tt> nodes which dominate either two or three children you would use pattern (<a href="#ex11">11</a>):</p>

<dl>
  <dt>(<a name="ex11">11</a>)</dt><dd><tt>NP &lt;2 __ !&lt;4 __</tt></dd>
</dl>

<h4><a name="sec12">12</a>&nbsp;&nbsp;&nbsp;Other relationships</h4>

<p align="justify">Other available relationships between nodes, additional to those given above in (<a href="#ex7">7</a>), are given in (<a href="#ex12">12</a>):</p>

<dl>
  <dt>(<a name="ex12">12</a>)</dt><dd></dd>
</dl>
<tt>&nbsp;&nbsp;A&nbsp;&lt;&lt;,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;is&nbsp;a&nbsp;leftmost&nbsp;descendant&nbsp;of&nbsp;A</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;&lt;-&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;is&nbsp;a&nbsp;rightmost&nbsp;descendant&nbsp;of&nbsp;A</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&gt;&gt;,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;a&nbsp;leftmost&nbsp;descendant&nbsp;of&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&gt;&gt;-&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;a&nbsp;rightmost&nbsp;descendant&nbsp;of&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;is&nbsp;the&nbsp;first&nbsp;child&nbsp;of&nbsp;A&nbsp;(synonymous&nbsp;with&nbsp;A&nbsp;&lt;1&nbsp;B)</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&gt;,&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;the&nbsp;first&nbsp;child&nbsp;of&nbsp;B&nbsp;(synonymous&nbsp;with&nbsp;A&nbsp;&gt;1&nbsp;B)</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;-&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;is&nbsp;the&nbsp;last&nbsp;child&nbsp;of&nbsp;A&nbsp;(synonymous&nbsp;with&nbsp;A&nbsp;&lt;-1&nbsp;B)</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&gt;-&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;the&nbsp;last&nbsp;child&nbsp;of&nbsp;B&nbsp;(synonymous&nbsp;with&nbsp;A&nbsp;&gt;-1&nbsp;B)</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;:&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;is&nbsp;the&nbsp;only&nbsp;child&nbsp;of&nbsp;A</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&gt;:&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;the&nbsp;only&nbsp;child&nbsp;of&nbsp;B</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&lt;&lt;:&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;dominates&nbsp;B&nbsp;via&nbsp;an&nbsp;unbroken&nbsp;chain&nbsp;(length&nbsp;&gt;&nbsp;0)&nbsp;of&nbsp;unary&nbsp;local&nbsp;trees</tt><br>
<tt>&nbsp;&nbsp;A&nbsp;&gt;&gt;:&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;is&nbsp;dominated&nbsp;by&nbsp;B&nbsp;via&nbsp;an&nbsp;unbroken&nbsp;chain&nbsp;(length&nbsp;&gt;&nbsp;0)&nbsp;of&nbsp;unary&nbsp;local&nbsp;trees</tt><br>

<h3><a name="sec4.3">4.3</a>&nbsp;&nbsp;&nbsp;Boolean expressions for building complex patterns</h3>

<p align="justify">Complex Tregex patterns can be constructed by specifying Boolean expressions of relationships that connect to a node. If no operator is placed between two relationships, they are assumed to be connected by an <i>and</i>, which can be specified for clarity with an ampersand (&lsquo;<tt>&</tt>&rsquo;). Thus, patterns (<a href="#ex13">13</a>) and (<a href="#ex14">14</a>) both match an <tt>IP</tt> node which immediately dominates a <tt>PP</tt> node <i>and</i> which dominates an <tt>IP</tt> node.</p>

<dl>
  <dt>(<a name="ex13">13</a>)</dt><dd><tt>&sol;^IP&#92;b&sol; &lt; &sol;^PP&#92;b&sol; &lt;&lt; &sol;^IP&#92;b&sol;</tt></dd>
</dl>

<dl>
  <dt>(<a name="ex14">14</a>)</dt><dd><tt>&sol;^IP&#92;b&sol; &lt; &sol;^PP&#92;b&sol; &amp; &lt;&lt; &sol;^IP&#92;b&sol;</tt></dd>
</dl>

<p align="justify">The second relationship &lsquo;<tt>&lt;&lt; &sol;^IP&#92;b&sol;</tt>&rsquo; refers to the first <tt>IP</tt> and not to the <tt>PP</tt>, and is equivalent to (<a href="#ex15">15</a>).</p>

<dl>
  <dt>(<a name="ex15">15</a>)</dt><dd><tt>(&sol;^IP&#92;b&sol; &lt; &sol;^PP&#92;b&sol;) &lt;&lt; &sol;^IP&#92;b&sol;</tt></dd>
</dl>

<p align="justify">The placement of parenthesis can be used to group a node with its relationship(s), so that (<a href="#ex16">16</a>) will match an <tt>IP</tt> which immediately dominates a <tt>PP</tt> which in turn dominates some <tt>IP</tt>.</p>

<dl>
  <dt>(<a name="ex16">16</a>)</dt><dd><tt>&sol;^IP&#92;b&sol; &lt; (&sol;^PP&#92;b&sol; &lt;&lt; &sol;^IP&#92;b&sol;)</tt></dd>
</dl>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;If a pipe (&lsquo;<tt>|</tt>&rsquo;) is placed between two relationships, only one of the relationships must be satisfied. Pattern (<a href="#ex17">17</a>) will find an <tt>IP</tt> node which immediately dominates a <tt>PP</tt> node or dominates an <tt>IP</tt> node:</p>

<dl>
  <dt>(<a name="ex17">17</a>)</dt><dd><tt>&sol;^IP&#92;b&sol; &lt; &sol;^PP&#92;b&sol; | &lt;&lt; &sol;^IP&#92;b&sol;</tt></dd>
</dl>

<p align="justify">The (possibly implicit) <i>and</i> binds tighter than the <i>or</i>. So pattern (<a href="#ex18">18</a>) will find an <tt>IP</tt> node that has <tt>VB</tt> and <tt>VB2</tt> children or that has <tt>NP-PRD</tt> and <tt>AX</tt> children.</p>

<dl>
  <dt>(<a name="ex18">18</a>)</dt><dd><tt>&sol;^IP&#92;b&sol; &lt; VB &lt; VB2 | &lt; NP-PRD &lt; AX</tt></dd>
</dl>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;To create more complex expressions, square brackets (&lsquo;<tt>[]</tt>&rsquo;) can be used to group relationships to form a complex relationship. Thus, pattern (<a href="#ex19">19</a>) finds an <tt>IP</tt> that has a <tt>VB</tt> or <tt>NP-PRD</tt> child, and that precedes a subject sister or follows an <tt>ADVP</tt> sister.</p>

<dl>
  <dt>(<a name="ex19">19</a>)</dt><dd><tt>&sol;^IP&#92;b&sol; [ &lt; VB | &lt; NP-PRD ] [ &dollar;..&nbsp;&sol;SBJ&sol; | &dollar;,,&nbsp;ADVP ]</tt></dd>
</dl>

<p align="justify">Because a square bracketed expression itself acts as a complex relationship connecting to a node, an open square bracket must immediately precede a relationship or another open square bracket that itself starts a complex relationship.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Any relationship, including a square bracketed one, can be negated by immediately preceding it with an exclamation mark (&lsquo;<tt>!</tt>&rsquo;). Thus, pattern (<a href="#ex20">20</a>) will find <tt>IP</tt> nodes that do not simultaneously have <tt>NP</tt> and <tt>PP</tt> children.</p>

<dl>
  <dt>(<a name="ex20">20</a>)</dt><dd><tt>&sol;^IP&#92;b&sol; ! [ &lt; &sol;^NP&#92;b&sol; &lt; &sol;^PP&#92;b&sol; ]</tt></dd>
</dl>

<h3><a name="sec4.4">4.4</a>&nbsp;&nbsp;&nbsp;Labeled nodes and back links</h3>

<p align="justify">As seen with the description in section <a href="#sec3">3</a> of Example 1, Tregex patterns allow for a matched node to be given a unique label with an equal sign (&lsquo;<tt>=</tt>&rsquo;) and then referred to by that label when Tsurgeon actions are triggered. It is also possible to use labels to refer to other nodes from within the Tregex pattern. Such a &lsquo;back link&rsquo; is accomplished when the node name only consists of an equal sign and a label, with the label serving to refer to the node that has been assigned to that name elsewhere in the pattern. It is only possible to express patterns in which the labeled node comes prior in the connected structure of the pattern that leads to a back link.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Having back links leads to the creation of patterns with cycles in the link structure. For example, imagine we wanted to find a clause node, <tt>&sol;^IP&#92;b&sol;</tt>, that dominates a clausal complement, <tt>&sol;THT&sol;</tt>, and a <tt>&sol;^PP&#92;b&sol;</tt>, such that the <tt>&sol;THT&sol;</tt> precedes the <tt>&sol;^PP&#92;b&sol;</tt>. This requires stating relationships between the <tt>&sol;^IP&#92;b&sol;</tt> and the <tt>&sol;THT&sol;</tt>, between the <tt>&sol;^IP&#92;b&sol;</tt> and the <tt>&sol;^PP&#92;b&sol;</tt>, and between the <tt>&sol;THT&sol;</tt> and the <tt>&sol;^PP&#92;b&sol;</tt>. With access to labels, the query can be written as (<a href="#ex21">21</a>).</p>

<dl>
  <dt>(<a name="ex21">21</a>)</dt><dd><tt>&sol;^IP&#92;b&sol;=foo &lt;&lt; (&sol;THT&sol;&nbsp;..&nbsp;(&sol;^PP&#92;b&sol; &gt;&gt; =foo))</tt></dd>
</dl>

<p align="justify">The <tt>&sol;^IP&sol;=foo</tt> matches any tree node whose name begins with <tt>IP</tt>. Furthermore, when a matching tree node is found, it is given the label <tt>foo</tt>. Later, &lsquo;<tt>&sol;^PP&#92;b&sol; &gt;&gt; =foo</tt>&rsquo; indicates that the <tt>PP</tt> must be dominated by that very same node, not just any <tt>IP</tt>.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;As another example of how back links are useful, consider the task of finding relative clauses with object traces. An object trace might be embedded arbitrarily deeply inside its relative clause, which is captured with the dominates relation (&lsquo;<tt>&lt;&lt; (&sol;OB1&sol; &lt; &sol;&#92;*T&#92;*&sol;)</tt>&rsquo;). However, without further qualification, this is too liberal, as it will also allow the return of a relative clause that itself has no object trace but contains a relative clause with an object trace. We can add the extra qualification to prohibit the unwelcome scenario with a back link, resulting in (<a href="#ex22">22</a>).</p>

<dl>
  <dt>(<a name="ex22">22</a>)</dt><dd><tt>&sol;REL&sol;=p &lt;&lt; (&sol;OB1&sol; &lt; &sol;&#92;*T&#92;*&sol; !&gt;&gt; (&sol;REL&sol; &gt;&gt; =p))</tt></dd>
</dl>

<p align="justify">The added back link statement (&lsquo;<tt>!&gt;&gt; (&sol;REL&sol; &gt;&gt; =p)</tt>&rsquo;) requires there to be no intervening relative clause (<tt>&sol;REL&sol;</tt>) between the object trace and the relative clause that the pattern serves to find.</p>

<h3><a name="sec4.5">4.5</a>&nbsp;&nbsp;&nbsp;Variable groups</h3>

<p align="justify">If you write a node description using a regular expression, you can assign its matching groups, established with round brackets internal to the regular expression, to variable names. The syntax is:</p>

<dl>
  <dt>(<a name="ex23">23</a>)</dt><dd><tt>&sol;regular-expression&sol;#group-number&#92;%variable-name</tt></dd>
</dl>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;If more than one node has a group assigned to the same variable name, then matching will only occur when all such groups capture the same string. For example, pattern (<a href="#ex24">24</a>) will find identical adjacent terminal nodes (reduplicated words).</p>

<dl>
  <dt>(<a name="ex24">24</a>)</dt><dd><tt>&sol;^(.+)&dollar;&sol;#1&#92;%word !&lt; __&nbsp;.&nbsp;(&sol;^(.+)&dollar;&sol;#1&#92;%word !&lt; __)</tt></dd>
</dl>

<p align="justify">Nodes matched with (<a href="#ex24">24</a>) have to be terminal because of the &lsquo;<tt>!&lt; __</tt>&rsquo; conditions that state how there can be no children, and adjacent because of the dot (&lsquo;<tt>.</tt>&rsquo;). With &lsquo;<tt>#1</tt>&rsquo;, <tt>word</tt> takes its value to be the first group in the regular expression, which is the word that needs to have occurred twice in a row.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;A major use of naming variable groups is to carry over named content into the <tt>relabel</tt> Tsurgeon action that is used to relabel node content (see section <a href="#sec5.4">5.4</a>).</p>

<h3><a name="sec4.6">4.6</a>&nbsp;&nbsp;&nbsp;Segmented patterns</h3>

<p align="justify">Tregex patterns can be split into multiple segments, which are separated by colons (&lsquo;<tt>:</tt>&rsquo;). Segments following the first can begin with a reference to a labeled node that is defined in a previous segment. Thus, pattern (<a href="#ex25">25</a>) will find trees where an <tt>NP</tt> immediately dominates a <tt>CP-THT</tt>.</p>

<dl>
  <dt>(<a name="ex25">25</a>)</dt><dd><tt>NP=x : =x &lt; CP-THT</tt></dd>
</dl>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;With labeling of complex nodes, segments can entirely replace patterns that otherwise require embedded relationships. For example, tree fragment (<a href="#ex26">26</a>) is matched by pattern (<a href="#ex27">27</a>) without segments as well as pattern (<a href="#ex28">28</a>) with segments.</p>

<dl>
  <dt>(<a name="ex26">26</a>)</dt><dd></dd>
</dl>

<svg xmlns:svg="http://www.w3.org/2000/svg" xmlns:exslt="http://exslt.org/common" width="161.7" height="304.5" viewBox="-16.5 17.5 204.6 395">
  <text x="85.8" y="55" text-anchor="middle">PP</text>
  <line x1="85.8" y1="70" x2="85.8" y2="100" style="stroke:#000000;stroke-width:2;"/>
  <rect x="70.8" y="105" width="30" height="30" rx="10" ry="10" style="fill: none; stroke: SandyBrown; stroke-width: 10;"/>
  <text x="85.8" y="125" text-anchor="middle">NP</text>
  <line x1="85.8" y1="140" x2="38.94" y2="170" style="stroke:#000000;stroke-width:2;"/>
  <line x1="85.8" y1="140" x2="124.74" y2="170" style="stroke:#000000;stroke-width:2;"/>
  <text x="38.94" y="195" text-anchor="middle">N</text>
  <line x1="38.94" y1="210" x2="38.94" y2="240" style="stroke:#000000;stroke-width:2;"/>
  <text x="38.94" y="265" text-anchor="middle">idea</text>
  <text x="124.74" y="195" text-anchor="middle">CP-THT</text>
  <line x1="124.74" y1="210" x2="124.74" y2="240" style="stroke:#000000;stroke-width:2;"/>
  <text x="124.74" y="265" text-anchor="middle">C</text>
  <line x1="124.74" y1="280" x2="124.74" y2="310" style="stroke:#000000;stroke-width:2;"/>
  <text x="124.74" y="335" text-anchor="middle">that</text>
</svg>

<dl>
  <dt>(<a name="ex27">27</a>)</dt><dd><tt>NP &lt; (N &lt; idea) &lt; (CP-THT &lt; (C &lt; that)) &gt; PP</tt></dd>
</dl>

<dl>
  <dt>(<a name="ex28">28</a>)</dt><dd><tt>NP=x : (=x &lt; N=n) : (=n &lt; idea) : (=x &lt; CP-THT=y) : (=y &lt; C=c) : (=c &lt; that) : (=x &gt; PP)</tt></dd>
</dl>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Segments can make patterns easier to read and debug. Segments can also assist with pattern reuse, especially when combined with macros (see section <a href="#sec6">6</a>). Patterns can frequently be mostly the same while differing in only one region. For such cases, the region that changes can be placed in its own segment, so that full patterns are built when a unique segment is appended to a common base, or vice versa.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Segments need not be related. Thus pattern (<a href="#ex29">29</a>) finds trees with an <tt>IP-ADV</tt> and <tt>IP-SUB</tt>, without other requirements for how these nodes relate to one another.</p>

<dl>
  <dt>(<a name="ex29">29</a>)</dt><dd><tt>IP-ADV : IP-SUB</tt></dd>
</dl>

<p align="justify">Note that the colon has a low precedence, so that (<a href="#ex30">30</a>) matches trees with an <tt>IP-SUB</tt> that does not immediately dominate a <tt>VBP</tt> and an <tt>IP-ADV</tt> that does immediately dominate a <tt>VBP</tt>.</p>

<dl>
  <dt>(<a name="ex30">30</a>)</dt><dd><tt>IP-ADV : (IP-SUB !&lt; VBP) &lt; VBP</tt></dd>
</dl>

<br>
<h2><a name="sec5">5</a>&nbsp;&nbsp;&nbsp;Tsurgeon actions</h2>

<p align="justify">With the previous section describing Tregex patterns, the current section turns to considering the range of Tsurgeon actions that Tregex patterns can invoke. Legal Tsurgeon actions are as follows:</p>
<tt>&nbsp;&nbsp;delete</tt><br>
<tt>&nbsp;&nbsp;prune</tt><br>
<tt>&nbsp;&nbsp;excise</tt><br>
<tt>&nbsp;&nbsp;relabel</tt><br>
<tt>&nbsp;&nbsp;move</tt><br>
<tt>&nbsp;&nbsp;replace</tt><br>
<tt>&nbsp;&nbsp;insert</tt><br>
<tt>&nbsp;&nbsp;createSubtree</tt><br>
<tt>&nbsp;&nbsp;adjoin</tt><br>
<tt>&nbsp;&nbsp;adjoinH</tt><br>
<tt>&nbsp;&nbsp;adjoinF</tt><br>
<tt>&nbsp;&nbsp;coindex</tt><br>

<p align="justify">We will look at these Tsurgeon actions in turn, with a description and example(s) for each.</p>

<h3><a name="sec5.1">5.1</a>&nbsp;&nbsp;&nbsp;delete</h3>
<tt>&nbsp;&nbsp;delete&nbsp;&lt;name_1&gt;&nbsp;&lt;name_2&gt;&nbsp;...&nbsp;&lt;name_m&gt;</tt><br>

<p align="justify">for each <tt>&lt;name_i&gt;</tt>, deletes the node it names and everything below it.</p>

<h4>Example 3</h4>

<p align="justify">The following script consists of a pattern to find nodes whose label starts with &lsquo;<tt>*</tt>&rsquo; and that do not dominate any other node. This pattern is paired with an action that deletes any matched node.</p>

<hr/>
<tt>&nbsp;&nbsp;&sol;^&#92;*&sol;=x&nbsp;!&lt;&nbsp;__</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;delete&nbsp;x</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;(NP-SBJ&nbsp;*speaker+hearer*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;NP-SBJ</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">Note that only the matched node, <tt>*speaker+hearer*</tt>, is removed, to leave <tt>NP-SBJ</tt> with no child.</p>

<h3><a name="sec5.2">5.2</a>&nbsp;&nbsp;&nbsp;prune</h3>
<tt>&nbsp;&nbsp;prune&nbsp;&lt;name_1&gt;&nbsp;&lt;name_2&gt;&nbsp;...&nbsp;&lt;name_m&gt;</tt><br>

<p align="justify">for each <tt>&lt;name_i&gt;</tt>, prunes out the named node. Pruning differs from deletion in that if pruning a node causes its parent to have no children, then the parent is in turn pruned too.</p>

<h4>Example 4</h4>

<p align="justify">The following script has the same pattern as seen with Example 3, but differs in terms of the action being <tt>prune</tt>.</p>

<hr/>
<tt>&nbsp;&nbsp;&sol;^&#92;*&sol;=x&nbsp;!&lt;&nbsp;__</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;prune&nbsp;x</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;(NP-SBJ&nbsp;*speaker+hearer*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">The <tt>*speaker+hearer*</tt> node is removed, and since this results in the <tt>NP-SBJ</tt> above it having no terminal children, the <tt>NP-SBJ</tt> node is deleted as well.</p>

<h3><a name="sec5.3">5.3</a>&nbsp;&nbsp;&nbsp;excise</h3>
<tt>&nbsp;&nbsp;excise&nbsp;&lt;name1&gt;&nbsp;&lt;name2&gt;</tt><br>

<p align="justify">The <tt>&lt;name1&gt;</tt> node should either dominate or be the same as the <tt>&lt;name2&gt;</tt> node. This excises out everything from <tt>&lt;name1&gt;</tt> to <tt>&lt;name2&gt;</tt>. All the children of <tt>&lt;name2&gt;</tt> go into the parent of <tt>&lt;name1&gt;</tt>, where <tt>&lt;name1&gt;</tt> was.</p>

<h4>Example 5</h4>

<p align="justify">The following script begins with the wild card pattern to identify a node that will dominate another node that is picked out with the <tt>x</tt> name and that will itself dominate at least one node that is dominating another node. The pattern is paired with an <tt>excise</tt> action that will remove nodes that can be named <tt>x</tt> from the tree.</p>

<hr/>
<tt>&nbsp;&nbsp;__&nbsp;&lt;&nbsp;(__=x&nbsp;&lt;&nbsp;(__&nbsp;&lt;&nbsp;__))</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;excise&nbsp;x&nbsp;x</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(FRAG&nbsp;(NP&nbsp;(PP&nbsp;(NP&nbsp;(PP&nbsp;(NP&nbsp;(N&nbsp;日本語))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;の))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;勉強))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;の))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;時間)))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(FRAG&nbsp;(N&nbsp;日本語)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;の)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;勉強)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;の)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;時間))</tt><br>

<p align="justify">This example has illustrated returning a flattened version of the input tree, with all non-root non-preterminal and non-terminal level nodes removed.</p>

<h4>Example 6</h4>

<p align="justify">With Example 5, an action to excise a single node was repeatedly applied. The following example illustrates excision of multiple nodes, with all inbetween material also being removed.</p>

<hr/>
<tt>&nbsp;&nbsp;PP=x&nbsp;&lt;&nbsp;NP=y</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;excise&nbsp;x&nbsp;y</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(FRAG&nbsp;(NP&nbsp;(PP&nbsp;(NP&nbsp;(PP&nbsp;(NP&nbsp;(N&nbsp;日本語))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;の))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;勉強))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;の))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;時間)))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(FRAG&nbsp;(NP&nbsp;(N&nbsp;日本語)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;勉強)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;時間)))</tt><br>

<p align="justify">From the input, there is repeated elimination of both a <tt>PP</tt> node and its dominated <tt>NP</tt> node, as well as all inbetween material, namely, the instances of:</p>
<tt>&nbsp;&nbsp;(PP&nbsp;NP</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P&nbsp;の))</tt><br>

<h3><a name="sec5.4">5.4</a>&nbsp;&nbsp;&nbsp;relabel</h3>
<tt>&nbsp;&nbsp;relabel&nbsp;&lt;name&gt;&nbsp;&lt;new-label&gt;</tt><br>

<p align="justify">relabels the node <tt>&lt;name&gt;</tt> to have a new label <tt>&lt;new-label&gt;</tt>. There are three possible forms for a relabelling instruction to take. The first form, illustrated with (<a href="#ex31">31</a>), is used for changing a node label (namely, <tt>nodeX</tt>) to an alphanumeric string (namely, <tt>NP</tt>).</p>

<dl>
  <dt>(<a name="ex31">31</a>)</dt><dd></dd>
</dl>
<tt>relabel&nbsp;nodeX&nbsp;NP</tt><br>

<p align="justify">The second form, illustrated with (<a href="#ex32">32</a>), is used for relabeling a node to something that isn't a valid identifier without quoting.</p>

<dl>
  <dt>(<a name="ex32">32</a>)</dt><dd></dd>
</dl>
<tt>relabel&nbsp;nodeX&nbsp;&sol;''&sol;</tt><br>

<p align="justify">The third form, illustrated with (<a href="#ex33">33</a>), is used for regular expression based relabeling.</p>

<dl>
  <dt>(<a name="ex33">33</a>)</dt><dd></dd>
</dl>
<tt>relabel&nbsp;nodeX&nbsp;&sol;^VB(.*)$&sol;verb&#92;&sol;$1&sol;</tt><br>

<p align="justify">The third form lets you make a new label that is an arbitrary String function of the original label and additional characters that you supply. In this last case, all matches of the regular expression against the node label are replaced with the replacement String. This has the semantics of Java&sol;Perl's <tt>replaceAll</tt>: you may use capturing groups and put them in replacements with <tt>&dollar;n</tt>. For example, if the pattern is <tt>&sol;foo&sol;bar&sol;</tt> and the node matched is <tt>foofoo</tt>, the <tt>replaceAll</tt> semantics results in <tt>barbar</tt>. If the pattern is <tt>&sol;^foo(.*)&dollar;&sol;bar&dollar;1&sol;</tt> and the node matched is <tt>foofoo</tt>, relabel will result in <tt>barfoo</tt>.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;When using the regex replacement method, the form of the regex is limited to literal character strings, the wild card character (&lsquo;<tt>.</tt>&rsquo;), the Kleene star (&lsquo;<tt>*</tt>&rsquo;), the string initial marker (&lsquo;<tt>^</tt>&rsquo;), and the string final marker (&lsquo;<tt>&dollar;</tt>&rsquo;). In order to utilise a more complex regex for use as replacement content, you can use the sequence <tt>&#92;%&lcub;var&rcub;</tt> in the replacement string to supply the content of a matched variable group (see section <a href="#sec4.5">4.5</a>). You can also use the sequence <tt>=&lcub;node&rcub;</tt> in the replacement string to use captured nodes in the replacement string (see Example 8 below). To get a &lsquo;<tt>%</tt>&rsquo; or an &lsquo;<tt>=</tt>&rsquo; or a slash in the replacement, escaping with &lsquo;<tt>&#92;</tt>&rsquo; is necessary, so: &lsquo;<tt>&#92;%</tt>&rsquo;, &lsquo;<tt>&#92;=</tt>&rsquo;, &lsquo;<tt>&#92;&sol;</tt>&rsquo;, and &lsquo;<tt>&#92;</tt>&rsquo;.</p>

<h4>Example 7</h4>

<p align="justify">The following pattern will look for a non-terminal node that contains a non-empty substring that starts with &lsquo;<tt>;&lcub;</tt>&rsquo; and ends with &lsquo;<tt>&rcub;</tt>&rsquo; without containing &lsquo;<tt>&rcub;</tt>&rsquo; and that should be preceded by a non-empty substring whose content is captured by the variable group name <tt>main</tt> and that is followed by a possibly empty substring whose content is captured by the variable group name <tt>rest</tt>. There follows an action that changes the label of the found node so that only the content of <tt>main</tt> and <tt>rest</tt> remain. Note that &lsquo;<tt>^.*&dollar;</tt>&rsquo; of the <tt>relabel</tt> action is necessary to make sure the regex pattern only matches and replaces once on the entire node label.</p>

<hr/>
<tt>&nbsp;&nbsp;&sol;^(.+);&#92;{[^}]+&#92;}(.*)$&sol;#1&#92;%main#2&#92;%rest=x&nbsp;&lt;&nbsp;__</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;x&nbsp;&sol;^.*$&sol;&#92;%{main}&#92;%{rest}&sol;</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(NP&nbsp;*ICH*-1)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(Q&nbsp;Everyone))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBD;~I&nbsp;ate)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-LOC&nbsp;(P-ROLE&nbsp;at)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-LOC;{BETTYS}-1&nbsp;(D&nbsp;a)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;cafe)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(NP&nbsp;*ICH*-1)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(Q&nbsp;Everyone))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBD;~I&nbsp;ate)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-LOC&nbsp;(P-ROLE&nbsp;at)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-LOC-1&nbsp;(D&nbsp;a)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;cafe)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>

<p align="justify">This example illustrates the content from two variable groups (<tt>main</tt> and <tt>rest</tt>) being carried over from the matched node to serve as the replacement content.</p>

<h4>Example 8</h4>

<p align="justify">The following pattern will look for a terminal node immediately dominated by an ID node and add the content of this node to every non-terminal node with content that is not ID and that does not already contain the to-be-added content.</p>

<hr/>
<tt>&nbsp;&nbsp;ID&nbsp;&lt;&nbsp;(__=label&nbsp;!&lt;&nbsp;__)&nbsp;:&nbsp;(&sol;^.&sol;=x&nbsp;&lt;&nbsp;__&nbsp;!==&nbsp;ID&nbsp;!==&nbsp;&sol;;(.+)&sol;#1&#92;%label)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;x&nbsp;&sol;^.*$&sol;={x};={label}&sol;</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(&nbsp;(IP-MAT&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;He))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBP&nbsp;laughs)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;(ID&nbsp;8_example))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(&nbsp;(IP-MAT;8_example&nbsp;(NP-SBJ;8_example&nbsp;(PRO;8_example&nbsp;He))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBP;8_example&nbsp;laughs)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU;8_example&nbsp;.))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;(ID&nbsp;8_example))</tt><br>

<h3><a name="sec5.5">5.5</a>&nbsp;&nbsp;&nbsp;move</h3>
<tt>&nbsp;&nbsp;move&nbsp;&lt;name&gt;&nbsp;&lt;position&gt;</tt><br>

<p align="justify">moves the named node into the specified position.  To be precise, it deletes (*NOT* prunes) the node from the tree, and re-inserts it into the specified position. See section <a href="#sec5.7">5.7</a> for how to specify position.</p>

<h4>Example 9</h4>

<p align="justify">This example demonstrates the promotion of punctuation (<tt>PU</tt>) to a higher constituent layer when on the left or right edge of a constituent layer (identified as &lsquo;<tt>y</tt>&rsquo;) that is dominated by at least one more node, that is, when &lsquo;<tt>y</tt>&rsquo; is not the root node of the tree. The first pattern-action pair covers the left edge scenario, while the second pattern-action pair covers the right edge scenario.</p>

<hr/>
<tt>&nbsp;&nbsp;PU=x&nbsp;&gt;1&nbsp;(__=y&nbsp;&gt;&nbsp;__)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;$+&nbsp;y</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;PU=x&nbsp;&gt;-1&nbsp;(__=y&nbsp;&gt;&nbsp;__)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;$-&nbsp;y</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(NP-SBJ&nbsp;(NPR&nbsp;Ben)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NPR&nbsp;Affleck))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(BEP&nbsp;is)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-PRD&nbsp;(D&nbsp;an)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;actor))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADVP-MOD&nbsp;(PU&nbsp;,)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADV&nbsp;too)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.)))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(NP-SBJ&nbsp;(NPR&nbsp;Ben)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NPR&nbsp;Affleck))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(BEP&nbsp;is)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-PRD&nbsp;(D&nbsp;an)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;actor))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;,)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADVP-MOD&nbsp;(ADV&nbsp;too))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>

<h4>Example 10</h4>

<p align="justify">The pattern contains a disjunction with two parts. The first part of the disjunction captures quantifier movement that occurs within the same (clause) layer. Here, the pattern involves a relation of sisterhood and precedence (&lsquo;<tt>&dollar;..</tt>&rsquo;) between a target position (&lsquo;<tt>x</tt>&rsquo;) that starts out as an immediate right sister of &lsquo;<tt>a</tt>&rsquo; and the constituent to move (&lsquo;<tt>b</tt>&rsquo;) that share its <tt>index</tt> with &lsquo;<tt>a</tt>&rsquo;. The second part of the disjunction captures quantifier raising that involves a move to a higher layer of structure, with the pattern involving a relation of domination (&lsquo;<tt>&lt;&lt;</tt>&rsquo;) from a sister of the target position (&lsquo;<tt>x</tt>&rsquo;). The action involves relabelling the &lsquo;<tt>a</tt>&rsquo; node with the <tt>main</tt> content from the &lsquo;<tt>b</tt>&rsquo; node (that is, the &lsquo;<tt>b</tt>&rsquo; node content minus the index and any material that either comes after the index or before the index but after a semi-colon (<tt>;</tt>)), relabelling the &lsquo;<tt>b</tt>&rsquo; node as <tt>NP</tt> together with the content of the &lsquo;<tt>b</tt>&rsquo; node that includes the index and any extra content that either comes after the index or comes before the index but after a semi-colon, followed by movement of &lsquo;<tt>a</tt>&rsquo; to be an immediate left sister of &lsquo;<tt>b</tt>&rsquo;, followed by movement of &lsquo;<tt>b</tt>&rsquo; to be an immediate left sister of &lsquo;<tt>x</tt>&rsquo;.</p>

<hr/>
<tt>&nbsp;&nbsp;__=x&nbsp;$,&nbsp;(NP=a&nbsp;&lt;&nbsp;&sol;^&#92;*ICH&#92;*-(&#92;p{Digit}+)$&sol;#1&#92;%index)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;$..&nbsp;&sol;^(NP&#92;b[^;]*)(.*)-(&#92;p{Digit}+)(.*)$&sol;#1&#92;%main#2&#92;%extra#3&#92;%index#4&#92;%rest=b&nbsp;|</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$&nbsp;(__&nbsp;&lt;&lt;&nbsp;&sol;^(NP&#92;b[^;]*)(.*)-(&#92;p{Digit}+)(.*)$&sol;#1&#92;%main#2&#92;%extra#3&#92;%index#4&#92;%rest=b)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;]</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;a&nbsp;&sol;^.*$&sol;&#92;%{main}&sol;</tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;b&nbsp;&sol;^.*$&sol;NP&#92;%{extra}-&#92;%{index}&#92;%{rest}&sol;</tt><br>
<tt>&nbsp;&nbsp;move&nbsp;a&nbsp;$+&nbsp;b</tt><br>
<tt>&nbsp;&nbsp;move&nbsp;b&nbsp;$+&nbsp;x</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(NP&nbsp;*ICH*-1)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(Q&nbsp;Everyone))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBD;~I&nbsp;ate)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-LOC&nbsp;(P-ROLE&nbsp;at)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-LOC;{BETTYS}-1&nbsp;(D&nbsp;a)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;cafe)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(NP;{BETTYS}-1&nbsp;(D&nbsp;a)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;cafe))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(Q&nbsp;Everyone))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBD;~I&nbsp;ate)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-LOC&nbsp;(P-ROLE&nbsp;at)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-LOC&nbsp;*ICH*-1))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>

<h3><a name="sec5.6">5.6</a>&nbsp;&nbsp;&nbsp;replace</h3>
<tt>&nbsp;&nbsp;replace&nbsp;&lt;name1&gt;&nbsp;&lt;name2&gt;</tt><br>

<p align="justify">deletes <tt>&lt;name1&gt;</tt> and inserts a copy of <tt>&lt;name2&gt;</tt> in its place.</p>
<tt>&nbsp;&nbsp;replace&nbsp;&lt;name&gt;&nbsp;&lt;tree&gt;&nbsp;&lt;tree2&gt;...</tt><br>

<p align="justify">deletes <tt>&lt;name&gt;</tt> and inserts the new tree(s) in its place. If more than one replacement tree is given, each of the new subtrees will be added in order where the old tree was. Multiple subtrees at the root is an illegal Tsurgeon action and will throw an exception.</p>

<h4>Example 11</h4>

<p align="justify">In the following example, replacement is made specific to matching <tt>(VB-VOL 考えよう)</tt>.</p>

<hr/>
<tt>&nbsp;&nbsp;VB-VOL=x&nbsp;&lt;&nbsp;考えよう</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;replace&nbsp;x&nbsp;(VB&nbsp;考え)&nbsp;(MD&nbsp;よう)</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;(VB-VOL&nbsp;考えよう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<h3><a name="sec5.7">5.7</a>&nbsp;&nbsp;&nbsp;insert</h3>
<tt>&nbsp;&nbsp;insert&nbsp;&lt;name&gt;&nbsp;&lt;position&gt;</tt><br>
<tt>&nbsp;&nbsp;insert&nbsp;&lt;tree&gt;&nbsp;&lt;position&gt;</tt><br>

<p align="justify">inserts the named node or tree into the position specified. The ways to specify position are:</p>
<tt>&nbsp;&nbsp;$+&nbsp;&lt;name&gt;&nbsp;&nbsp;&nbsp;the&nbsp;left&nbsp;sister&nbsp;of&nbsp;the&nbsp;named&nbsp;node</tt><br>
<tt>&nbsp;&nbsp;$-&nbsp;&lt;name&gt;&nbsp;&nbsp;&nbsp;the&nbsp;right&nbsp;sister&nbsp;of&nbsp;the&nbsp;named&nbsp;node</tt><br>
<tt>&nbsp;&nbsp;&gt;i&nbsp;&lt;name&gt;&nbsp;&nbsp;&nbsp;the&nbsp;i_th&nbsp;daughter&nbsp;of&nbsp;the&nbsp;named&nbsp;node.</tt><br>
<tt>&nbsp;&nbsp;&gt;-i&nbsp;&lt;name&gt;&nbsp;&nbsp;the&nbsp;i_th&nbsp;daughter,&nbsp;counting&nbsp;from&nbsp;the&nbsp;right,&nbsp;of&nbsp;the&nbsp;named&nbsp;node.</tt><br>

<h4>Example 12</h4>

<p align="justify">The transformation seen with Example 11 can be achieved more generally with:</p>

<hr/>
<tt>&nbsp;&nbsp;VB-VOL=x&nbsp;&lt;&nbsp;&sol;^(.+)よう$&sol;#1&#92;%stem</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;insert&nbsp;(VB&nbsp;=y)&nbsp;$+&nbsp;x</tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;y&nbsp;&sol;^.*$&sol;&#92;%{stem}&sol;</tt><br>
<tt>&nbsp;&nbsp;replace&nbsp;x&nbsp;(MD&nbsp;よう)</tt><br>

<hr/>

<p align="justify">Note that the <tt>insert</tt> and <tt>relabel</tt> combination occurs before <tt>replace</tt>. This ordering is important because following <tt>replace</tt> the content of the <tt>stem</tt> variable is lost.</p>

<h3><a name="sec5.8">5.8</a>&nbsp;&nbsp;&nbsp;createSubtree</h3>
<tt>&nbsp;&nbsp;createSubtree&nbsp;&lt;auxiliary-tree-or-label&gt;&nbsp;&lt;name1&gt;&nbsp;[&lt;name2&gt;]</tt><br>

<p align="justify">creates a subtree out of all the nodes from <tt>name1</tt> through <tt>name2</tt>. The subtree is moved to the foot of the given auxiliary tree, and the tree is inserted where the nodes of the subtree used to reside. If a simple label is provided as the first argument, the subtree is given a single parent with a name corresponding to the label. To limit the Tsurgeon action to just one node, elide <tt>name2</tt>.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Auxiliary trees must have exactly one frontier node ending in the character &lsquo;<tt>&#64;</tt>&rsquo;, which marks it as the &lsquo;foot&rsquo; node for adjunction. Final instances of the character &lsquo;<tt>&#64;</tt>&rsquo; in terminal node labels will be removed from the actual label of the tree.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;All other instances of &lsquo;<tt>&#64;</tt>&rsquo; in terminal nodes must be escaped (i.e., appear as <tt>&#92;&#64;</tt>); this escaping will be removed by Tsurgeon.</p>

<h4>Example 13</h4>

<p align="justify">The first pattern-action pair creates a right binarization of the input tree with the creation of &lsquo;artificial&rsquo; non-terminal nodes (<tt>ILYR</tt>) that span between the second node (&lsquo;<tt>&lt;2 __=x</tt>&rsquo;) and the end node (&lsquo;<tt>&lt;-1 __=y</tt>&rsquo;) of a constituent with at least three nodes (&lsquo;<tt>&lt;3 __</tt>&rsquo;) and that contains a main verb that has a preceding sister (&lsquo;<tt>&lt; (&sol;^V&sol; &dollar;, __)</tt>&rsquo;).</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;The second pattern-action pair creates a left binarization of the input tree with the creation of <tt>ILYR</tt> nodes that span between the first node (&lsquo;<tt>&lt;1 __=x</tt>&rsquo;) and the second to last node (&lsquo;<tt>&lt;-2 __=y</tt>&rsquo;) of a constituent with at least three nodes (&lsquo;<tt>&lt;3 __</tt>&rsquo;).</p>

<hr/>
<tt>&nbsp;&nbsp;__&nbsp;&lt;2&nbsp;__=x&nbsp;&lt;-1&nbsp;__=y&nbsp;&lt;3&nbsp;__&nbsp;&lt;&nbsp;(&sol;^V&sol;&nbsp;$,&nbsp;__)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;createSubtree&nbsp;ILYR&nbsp;x&nbsp;y</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;__&nbsp;&lt;1&nbsp;__=x&nbsp;&lt;-2&nbsp;__=y&nbsp;&lt;3&nbsp;__</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;createSubtree&nbsp;ILYR&nbsp;x&nbsp;y</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(&nbsp;(IP-MAT&nbsp;(ADVP-TMP&nbsp;(ADV&nbsp;Yesterday))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;,)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(N&nbsp;Mr.)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NPR&nbsp;Ito))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBD&nbsp;ate)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-OB1&nbsp;(N&nbsp;pizza))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-COM&nbsp;(P-ROLE&nbsp;with)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(N&nbsp;Ms.)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NPR&nbsp;Yamada)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-LOC&nbsp;(P-ROLE&nbsp;in)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(NPR&nbsp;Shibuya)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;(ID&nbsp;8_texts_purple_basic))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(&nbsp;(IP-MAT&nbsp;(ADVP-TMP&nbsp;(ADV&nbsp;Yesterday))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ILYR&nbsp;(PU&nbsp;,)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ILYR&nbsp;(NP-SBJ&nbsp;(N&nbsp;Mr.)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NPR&nbsp;Ito))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ILYR&nbsp;(ILYR&nbsp;(ILYR&nbsp;(ILYR&nbsp;(VBD&nbsp;ate)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-OB1&nbsp;(N&nbsp;pizza)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-COM&nbsp;(P-ROLE&nbsp;with)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(N&nbsp;Ms.)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NPR&nbsp;Yamada))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-LOC&nbsp;(P-ROLE&nbsp;in)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(NPR&nbsp;Shibuya))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.)))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;(ID&nbsp;8_texts_purple_basic))</tt><br>

<p align="justify">Notably, the output gives the main verb as the most embedded element surrounded by the left binarization of following elements, which in turn is followed by the right binarization of preceding elements.</p>

<h3><a name="sec5.9">5.9</a>&nbsp;&nbsp;&nbsp;adjoin</h3>
<tt>&nbsp;&nbsp;adjoin&nbsp;&lt;auxiliary-tree&gt;&nbsp;&lt;target-node&gt;</tt><br>

<p align="justify">adjoins the specified <tt>&lt;auxiliary-tree&gt;</tt> into the specified <tt>&lt;target-node&gt;</tt>. The daughters of the target node will become the daughters of the foot of the auxiliary tree.</p>

<h4>Example 14</h4>

<p align="justify">The following example has a pattern to find nodes with labels that start with <tt>NLYR</tt> and do not dominate nodes that start with <tt>*ICH*</tt> or <tt>CONJP</tt>. This pattern is paired with an action that replaces the matched node with an <tt>NP</tt> node that furthermore has a <tt>PP</tt> projection that contains an initial <tt>(P-ROLE #)</tt> element.</p>

<hr/>
<tt>&nbsp;&nbsp;&sol;^NLYR&#92;b&sol;=x&nbsp;!&lt;&nbsp;&sol;^(&#92;*ICH&#92;*|CONJP&#92;b)&sol;</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;adjoin&nbsp;(PP&nbsp;(P-ROLE&nbsp;#)&nbsp;NP&#64;)&nbsp;x</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(NP&nbsp;(NLYR&nbsp;(NLYR&nbsp;(ADJP&nbsp;(ADJ&nbsp;liquid))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;phase))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADJP&nbsp;(ADJ&nbsp;thermal))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;reaction))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NS&nbsp;studies))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(NP&nbsp;(PP&nbsp;(P-ROLE&nbsp;#)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(PP&nbsp;(P-ROLE&nbsp;#)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(ADJP&nbsp;(ADJ&nbsp;liquid))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;phase)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADJP&nbsp;(ADJ&nbsp;thermal))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;reaction)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NS&nbsp;studies))</tt><br>

<h3><a name="sec5.10">5.10</a>&nbsp;&nbsp;&nbsp;adjoinH</h3>
<tt>&nbsp;&nbsp;adjoinH&nbsp;&lt;auxiliary-tree&gt;&nbsp;&lt;target-node&gt;</tt><br>

<p align="justify">is similar to <tt>adjoin</tt>, but preserves the <tt>&lt;target-node&gt;</tt> and makes it the root of <tt>&lt;auxiliary-tree&gt;</tt>. The root of the <tt>&lt;auxiliary-tree&gt;</tt> is ignored.</p>

<h4>Example 15</h4>

<p align="justify">This illustrates the addition of an <tt>NLYR</tt> layer into a noun phrase that dominates a <tt>CONJP</tt> node.</p>

<hr/>
<tt>&nbsp;&nbsp;&sol;^NP&#92;b&sol;=x&nbsp;&lt;&nbsp;(CONJP&nbsp;!&gt;&nbsp;&sol;^NLYR&sol;)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;adjoinH&nbsp;(&nbsp;NLYR&#64;)&nbsp;x</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(NP&nbsp;(NP&nbsp;(NP&nbsp;Pat))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CONJP&nbsp;(CONJ&nbsp;and)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(NPR&nbsp;Tony))))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(NP&nbsp;(NLYR&nbsp;(NP&nbsp;(NP&nbsp;Pat))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CONJP&nbsp;(CONJ&nbsp;and)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(NPR&nbsp;Tony)))))</tt><br>

<h3><a name="sec5.11">5.11</a>&nbsp;&nbsp;&nbsp;adjoinF</h3>
<tt>&nbsp;&nbsp;adjoinF&nbsp;&lt;auxiliary-tree&gt;&nbsp;&lt;target-node&gt;</tt><br>

<p align="justify">is similar to <tt>adjoin</tt>, but preserves the <tt>&lt;target-node&gt;</tt> and makes it the foot of <tt>&lt;auxiliary-tree&gt;</tt>. The foot of the <tt>&lt;auxiliary-tree&gt;</tt> is ignored.</p>

<h4>Example 16</h4>

<p align="justify">The first pattern-action pair adds a <tt>ZERO</tt> node above terminal nodes that start with <tt>&lsquo;*&rsquo;</tt> and are dominated by an <tt>NP</tt> node. The second pattern-action pair adds a <tt>WORD</tt> node above terminal nodes that are not dominated by <tt>WORD</tt> (thus, ensuring termination), <tt>ZERO</tt>, or a node that begins with <tt>PU</tt>.</p>

<hr/>
<tt>&nbsp;&nbsp;&sol;^&#92;*&sol;=x&nbsp;!&lt;&nbsp;__&nbsp;&gt;&nbsp;&sol;^NP&#92;b&sol;</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;adjoinF&nbsp;(ZERO&nbsp;&#64;)&nbsp;x</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;__=x&nbsp;!&lt;&nbsp;__&nbsp;!&gt;&nbsp;&sol;^(WORD$|ZERO$|PU)&sol;</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;adjoinF&nbsp;(WORD&nbsp;&#64;)&nbsp;x</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;(NP-SBJ&nbsp;*speaker+hearer*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;考え)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;よう)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-IMP&nbsp;(NP-SBJ&nbsp;(ZERO&nbsp;*speaker+hearer*))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;(WORD&nbsp;考え))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(MD&nbsp;(WORD&nbsp;よう))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;。))</tt><br>

<h3><a name="sec5.12">5.12</a>&nbsp;&nbsp;&nbsp;coindex</h3>
<tt>&nbsp;&nbsp;coindex&nbsp;&lt;name_1&gt;&nbsp;&lt;name_2&gt;&nbsp;...&nbsp;&lt;name_m&gt;</tt><br>

<p align="justify">puts a (Penn Treebank style) coindexation suffix of the form &lsquo;-<m>n</m>&rsquo; on each of nodes <tt>&lt;name_1&gt;</tt> through <tt>&lt;name_m&gt;</tt>. The value of <m>n</m> will be generated in reference to the existing coindexations in the tree, thus avoiding an accidental clash of indices across things that are not meant to be coindexed.</p>

<h4>Example 17</h4>

<p align="justify">The following pattern contains two pattern segments (see section <a href="#sec4.6">4.6</a>). The first pattern segment matches a node (identified as &lsquo;<tt>x</tt>&rsquo;) that: (i) contains a non-empty substring that starts with &lsquo;<tt>;&lcub;</tt>&rsquo; and ends with &lsquo;<tt>&rcub;</tt>&rsquo; and that is referenced with the variable group name <tt>index</tt>, (ii) doesn't dominate a <tt>PRO</tt> node, (iii) is contained within a node (identified as &lsquo;<tt>y</tt>&rsquo;) that has <tt>CND</tt> as a substring (a constituent layer that will be the antecedent of a conditional), and (iv) has a leftmost terminal descendant (identified as &lsquo;<tt>a</tt>&rsquo;) that doesn't end within an index string. The second pattern segment matches a node that: (i) contains a non-empty substring that starts with &lsquo;<tt>;&lcub;</tt>&rsquo; and ends with &lsquo;<tt>&rcub;</tt>&rsquo; and is the same string referenced with the variable group name <tt>index</tt> of the first pattern segment, (ii) dominates a <tt>PRO</tt> node, (iii) precedes the node referenced as &lsquo;<tt>x</tt>&rsquo; by the first pattern segment, (iv) is not contained within the node referenced as &lsquo;<tt>y</tt>&rsquo; by the first pattern segment, and (v) has a leftmost terminal descendant (identified as &lsquo;<tt>b</tt>&rsquo;) that doesn't end within an index string. When the overall pattern is satisfied an action is triggered to coindex the nodes identified with &lsquo;<tt>a</tt>&rsquo; and &lsquo;<tt>b</tt>&rsquo;.</p>

<hr/>
<tt>&nbsp;&nbsp;&sol;;(&#92;{[^}]+&#92;})&sol;#1&#92;%index=x&nbsp;!&lt;&nbsp;&sol;^PRO&#92;b&sol;&nbsp;&gt;&gt;&nbsp;&sol;&#92;bCND&#92;b&sol;=y&nbsp;&lt;&lt;,&nbsp;(!&sol;-&#92;p{Digit}+$&sol;=a&nbsp;!&lt;&nbsp;__)&nbsp;:</tt><br>
<tt>&nbsp;&nbsp;(&sol;;(&#92;{[^}]+&#92;})&sol;#1&#92;%index&nbsp;&lt;&nbsp;&sol;^PRO&#92;b&sol;&nbsp;,,&nbsp;=x&nbsp;!&gt;&gt;&nbsp;=y&nbsp;&lt;&lt;,&nbsp;(!&sol;-&#92;p{Digit}+$&sol;=b&nbsp;!&lt;&nbsp;__))</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;coindex&nbsp;a&nbsp;b</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(PP-SCON-CNT-CND&nbsp;(P-CONN&nbsp;If)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IP-ADV&nbsp;(NP-SBJ&nbsp;(D&nbsp;a)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;farmer))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBP&nbsp;owns)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-OB1;{DONKEY}&nbsp;(D&nbsp;a)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;donkey))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;he))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBP&nbsp;beats)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-OB1;{DONKEY}&nbsp;(PRO&nbsp;it))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(PP-SCON-CNT-CND&nbsp;(P-CONN&nbsp;If)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IP-ADV&nbsp;(NP-SBJ&nbsp;(D&nbsp;a)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;farmer))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBP&nbsp;owns)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-OB1;{DONKEY}&nbsp;(D&nbsp;a-1)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(N&nbsp;donkey))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-SBJ&nbsp;(PRO&nbsp;he))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VBP&nbsp;beats)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP-OB1;{DONKEY}&nbsp;(PRO&nbsp;it-1))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;.))</tt><br>

<p align="justify">While a yield of the input tree gives (<a href="#ex34">34</a>):</p>

<dl>
  <dt>(<a name="ex34">34</a>)</dt><dd></dd>
</dl>
<tt>If&nbsp;a&nbsp;farmer&nbsp;owns&nbsp;a&nbsp;donkey&nbsp;he&nbsp;beats&nbsp;it&nbsp;.</tt><br>

<p align="justify">a yield of the output tree gives (<a href="#ex35">35</a>):</p>

<dl>
  <dt>(<a name="ex35">35</a>)</dt><dd></dd>
</dl>
<tt>If&nbsp;a&nbsp;farmer&nbsp;owns&nbsp;a-1&nbsp;donkey&nbsp;he&nbsp;beats&nbsp;it-1&nbsp;.</tt><br>

<p align="justify">That is, the change serves to retain the anaphoric link information following a yield.</p>

<br>
<h2><a name="sec6">6</a>&nbsp;&nbsp;&nbsp;Adding macros with <tt>m4</tt></h2>

<p align="justify"><tt>m4</tt> is a general-purpose macro processor that can be used to preprocess Tsurgeon scripts. The basic operation of <tt>m4</tt> is to read input and determine if the input contains any macro names. If a macro name is found, the name is replaced by its defining text, with and the resulting changed input is rescanned. As a consequence, text replacements can themselves contain macro calls. Macros can be called with arguments. The arguments are collected and substituted into the right places in the defining text before the defining text is rescanned.</p>

<p align="justify">&nbsp;&nbsp;&nbsp;&nbsp;Note that if <tt>m4</tt> is used as a preprocessor, instances of &lsquo;<tt>#</tt>&rsquo; used to mark variable groups in patterns (see section <a href="#sec4.5">4.5</a>) should be placed between a backquote character (<tt>`</tt>) and a single quote character (<tt>'</tt>). For example, (<a href="#ex36">36</a>),</p>

<dl>
  <dt>(<a name="ex36">36</a>)</dt><dd></dd>
</dl>
<tt>&sol;^([^*]+)$&sol;#1&#92;%word</tt><br>

<p align="justify">should become (<a href="#ex37">37</a>):</p>

<dl>
  <dt>(<a name="ex37">37</a>)</dt><dd></dd>
</dl>
<tt>&sol;^([^*]+)$&sol;`#'1&#92;%word</tt><br>

<h4>Example 18</h4>

<p align="justify">This example contains actions that will move <tt>PP</tt> constituents (&lsquo;<tt>x</tt>&rsquo;) with <tt>IP-CTL</tt> that have no potential controllers of the containing clause in preceding positions to a position that makes the subject binding of the clause (&lsquo;<tt>y</tt>&rsquo;) its immediately preceding sister. This is accomplished with reference to two macros. The first macro defines <tt>_pp</tt> which can receive either no arguments or a single argument that is a node name to create a search pattern for finding <tt>PP</tt> nodes. The second macro defines <tt>_controllers_all_following</tt>, which includes calls to the <tt>_pp</tt> macro (with argument and without). This second macro is used to name the subject that is following in the containing clause, and prohibit the possibility of there being preceding arguments with <tt>ROLE</tt> dominating a node prefixed <tt>ARG</tt> &mdash; potential controllers.</p>

<hr/>
<tt>&nbsp;&nbsp;define(`_pp',&nbsp;`ifelse(`$#',&nbsp;`0',&nbsp;`&sol;^PP&#92;b&sol;',&nbsp;`&sol;^PP&#92;b&sol;=$1')')dnl</tt><br>
<tt>&nbsp;&nbsp;define(`_controllers_all_following',&nbsp;`$..&nbsp;(_pp($1)&nbsp;&lt;&nbsp;(&sol;^ROLE&sol;&nbsp;&lt;&nbsp;&sol;^ARG0&sol;)&nbsp;!$,,&nbsp;(_pp&nbsp;&lt;&nbsp;(&sol;^ROLE&sol;&nbsp;&lt;&nbsp;&sol;^ARG&sol;)))&nbsp;!$,,&nbsp;(_pp&nbsp;&lt;&nbsp;(&sol;^ROLE&sol;&nbsp;&lt;&nbsp;&sol;^ARG&sol;))')dnl</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&sol;^IP-CTL&sol;=x&nbsp;_controllers_all_following(y)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;$-&nbsp;y</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;_pp(x)&nbsp;&lt;&nbsp;&sol;^IP-CTL&sol;&nbsp;_controllers_all_following(y)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;$-&nbsp;y</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;_pp(x)&nbsp;&lt;&nbsp;(&sol;^CP-THT&sol;&nbsp;&lt;&nbsp;(&sol;^IP-CTL&sol;))&nbsp;_controllers_all_following(y)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;$-&nbsp;y</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(PP&nbsp;(CONN&nbsp;If)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IP-CTL&nbsp;(VB&nbsp;laughing)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP&nbsp;(ROLE&nbsp;ARG0)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(N&nbsp;boy)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;COPULA_is)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADXP&nbsp;(ADX&nbsp;happy)))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(IP-MAT&nbsp;(PP&nbsp;(ROLE&nbsp;ARG0)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(NP&nbsp;(N&nbsp;boy)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP&nbsp;(CONN&nbsp;If)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IP-CTL&nbsp;(VB&nbsp;laughing)))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;COPULA_is)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ADXP&nbsp;(ADX&nbsp;happy)))</tt><br>

<br>
<h2><a name="sec7">7</a>&nbsp;&nbsp;&nbsp;An extended example</h2>

<p align="justify">Clause-level coordination in the NINJAL Parsed Corpus of Modern Japanese (NPCMJ) is represented by placing the content of clausal conjuncts that are prior to the last conjunct under stacked subordinate <tt>IP-ADV</tt> nodes that contain a <tt>-CONJ</tt> extension or that are followed by a conjunction marker (<tt>CONJ</tt>) (possibly with intervening punctuation) (or both). Example 19 demonstrates how it is possible to transform this coding of clause-level coordination with subordinate structure into a coding that has coordinate structure with <tt>CONJP</tt> and <tt>ILYR</tt> (clause intermediate level) nodes.</p>

<h4>Example 19</h4>

<hr/>
<tt>&nbsp;&nbsp;&sol;^IP-ADV-CONJ&sol;=x&nbsp;$.&nbsp;(PU&nbsp;$.&nbsp;CONJ)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;x&nbsp;&sol;^IP-ADV-CONJ(.*)$&sol;IP-ADV$1&sol;</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&sol;^IP-ADV&sol;&nbsp;$.&nbsp;(PU=y&nbsp;$.&nbsp;CONJ=x)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;adjoinF&nbsp;(ILYR&nbsp;CONJP&nbsp;&#64;&nbsp;ILYR)&nbsp;x</tt><br>
<tt>&nbsp;&nbsp;move&nbsp;y&nbsp;$+&nbsp;x</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&sol;^IP-ADV-CONJ&sol;=x&nbsp;!$.&nbsp;CONJ</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;x&nbsp;&sol;^IP-ADV-CONJ(.*)$&sol;IP-ADV$1&sol;</tt><br>
<tt>&nbsp;&nbsp;insert&nbsp;(CONJ&nbsp;*)&nbsp;$-&nbsp;x</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&sol;^IP-ADV&sol;&nbsp;$.&nbsp;CONJ=x</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;adjoinF&nbsp;(ILYR&nbsp;CONJP&nbsp;&#64;&nbsp;ILYR)&nbsp;x</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&sol;^IP-ADV(.*)$&sol;#1&#92;%extra=x&nbsp;$.&nbsp;(ILYR&nbsp;&lt;1&nbsp;(CONJP=y&nbsp;!&lt;&nbsp;__))</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;&gt;1&nbsp;y</tt><br>
<tt>&nbsp;&nbsp;relabel&nbsp;x&nbsp;&sol;^.*$&sol;ILYR&#92;%{extra}&sol;</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;ILYR&nbsp;&lt;&nbsp;CONJ&nbsp;&lt;-1&nbsp;ILYR=y&nbsp;$.&nbsp;__=x</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;&gt;-1&nbsp;y</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;CONJP&nbsp;$.&nbsp;(CONJ=x&nbsp;&lt;&nbsp;&sol;^&#92;*$&sol;)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;delete&nbsp;x</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;CONJP=z&nbsp;$.&nbsp;(PU=y&nbsp;$.&nbsp;CONJ=x)</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;y&nbsp;&gt;-1&nbsp;z</tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;&gt;-1&nbsp;z</tt><br>
<tt></tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;CONJP=z&nbsp;$.&nbsp;CONJ=x</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;move&nbsp;x&nbsp;&gt;-1&nbsp;z</tt><br>

<hr/>

<p align="justify">Input:</p>
<tt>&nbsp;&nbsp;(&nbsp;(IP-MAT&nbsp;(NP-SBJ&nbsp;*speaker*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(IP-ADV-CONJ&nbsp;(VB&nbsp;わかり)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(AX&nbsp;まし)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(AXD&nbsp;た))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;、)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CONJ&nbsp;では)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;、)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-OB1&nbsp;(NP&nbsp;(PRO&nbsp;それ))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P-ROLE&nbsp;を))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;確認)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB0&nbsp;し)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P-CONN&nbsp;て))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;(ID&nbsp;42_spoken_JF2))</tt><br>

<p align="justify">Output:</p>
<tt>&nbsp;&nbsp;(&nbsp;(IP-MAT&nbsp;(NP-SBJ&nbsp;*speaker*)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ILYR&nbsp;(CONJP&nbsp;(ILYR&nbsp;(VB&nbsp;わかり)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(AX&nbsp;まし)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(AXD&nbsp;た))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PU&nbsp;、)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CONJ&nbsp;では))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ILYR&nbsp;(PU&nbsp;、)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(PP-OB1&nbsp;(NP&nbsp;(PRO&nbsp;それ))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P-ROLE&nbsp;を))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB&nbsp;確認)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(VB0&nbsp;し)</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(P-CONN&nbsp;て))))</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;(ID&nbsp;42_spoken_JF2))</tt><br>

<br>
<h2><a name="sec8">8</a>&nbsp;&nbsp;&nbsp;Running Tsurgeon</h2>

<p align="justify">This section notes how to run Tsurgeon from the command prompt with the <tt>tsurgeon_script</tt> wrapper script. This wrapper script is available from: <tt><a href="http:&sol;&sol;www.compling.jp&sol;ajb129">http:&sol;&sol;www.compling.jp&sol;ajb129</a></tt>.</p>
<tt>NAME</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsurgeon_script&nbsp;-&nbsp;pipeline&nbsp;tsurgeon</tt><br>
<tt></tt><br>
<tt>SYNOPSIS</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tsurgeon_script&nbsp;script</tt><br>
<tt></tt><br>
<tt>DESCRIPTION</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This&nbsp;wrapper&nbsp;script&nbsp;runs&nbsp;stanford-tregex.jar&nbsp;in&nbsp;the&nbsp;tsurgeon&nbsp;mode</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;as&nbsp;a&nbsp;filter&nbsp;changing&nbsp;stdin.&nbsp;&nbsp;At&nbsp;least&nbsp;one&nbsp;tsurgeon&nbsp;script&nbsp;must&nbsp;be</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;supplied.</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;tsurgeon&nbsp;script&nbsp;is&nbsp;a&nbsp;file&nbsp;containing&nbsp;a&nbsp;list&nbsp;of&nbsp;pattern&nbsp;and</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;transformation&nbsp;operation&nbsp;list&nbsp;pairs.&nbsp;&nbsp;That&nbsp;is,&nbsp;it&nbsp;is&nbsp;a&nbsp;sequence&nbsp;of</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pairs&nbsp;of&nbsp;a&nbsp;Tregex&nbsp;pattern&nbsp;on&nbsp;one&nbsp;or&nbsp;more&nbsp;lines,&nbsp;then&nbsp;a&nbsp;blank&nbsp;line</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(empty&nbsp;or&nbsp;whitespace),&nbsp;then&nbsp;a&nbsp;list&nbsp;of&nbsp;transformation&nbsp;operations</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;one&nbsp;per&nbsp;line&nbsp;to&nbsp;apply&nbsp;when&nbsp;the&nbsp;pattern&nbsp;is&nbsp;matched,&nbsp;and&nbsp;then</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;another&nbsp;blank&nbsp;line&nbsp;(empty&nbsp;or&nbsp;whitespace).&nbsp;&nbsp;Note&nbsp;the&nbsp;need&nbsp;for&nbsp;blank</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lines:&nbsp;The&nbsp;code&nbsp;crashes&nbsp;if&nbsp;they&nbsp;are&nbsp;not&nbsp;present&nbsp;as&nbsp;separators.</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The&nbsp;character&nbsp;%&nbsp;introduces&nbsp;a&nbsp;comment&nbsp;that&nbsp;extends&nbsp;to&nbsp;the&nbsp;end&nbsp;of&nbsp;the</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line.&nbsp;&nbsp;All&nbsp;other&nbsp;intended&nbsp;uses&nbsp;of&nbsp;%&nbsp;must&nbsp;be&nbsp;escaped&nbsp;as&nbsp;&#92;%&nbsp;.</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Before&nbsp;tsurgeon&nbsp;gets&nbsp;to&nbsp;see&nbsp;any&nbsp;script&nbsp;content,&nbsp;the&nbsp;script&nbsp;content</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;passed&nbsp;through&nbsp;the&nbsp;m4&nbsp;macro&nbsp;processor.</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instances&nbsp;of&nbsp;#&nbsp;used&nbsp;to&nbsp;mark&nbsp;variable&nbsp;groups&nbsp;in&nbsp;patterns&nbsp;should&nbsp;be</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;placed&nbsp;between&nbsp;a&nbsp;backquote&nbsp;character&nbsp;and&nbsp;a&nbsp;single&nbsp;quote&nbsp;character.</tt><br>
<tt></tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Also&nbsp;lines&nbsp;that&nbsp;begin&nbsp;.R&nbsp;and&nbsp;end&nbsp;.E&nbsp;are&nbsp;commented&nbsp;out.&nbsp;It&nbsp;is&nbsp;not</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;necessary&nbsp;to&nbsp;close&nbsp;.R,&nbsp;in&nbsp;which&nbsp;case&nbsp;all&nbsp;lines&nbsp;are&nbsp;commented&nbsp;out</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;the&nbsp;instance&nbsp;of&nbsp;.R&nbsp;to&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;given&nbsp;script.</tt><br>
<tt></tt><br>
<tt>OPTIONS</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--debug)&nbsp;&nbsp;&nbsp;#&nbsp;see&nbsp;modified&nbsp;script</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;show&nbsp;this&nbsp;help&nbsp;message</tt><br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;filename&nbsp;to&nbsp;source&nbsp;the&nbsp;tsurgeon&nbsp;script&nbsp;content</tt><br>

<br>
<br>
<br>
<h2><a name="references">References</a></h2>

<p><a name="Levy-and-Andrew-2006">Levy, Roger and Galen Andrew. 2006.</a> Tregex and Tsurgeon: tools for querying and manipulating tree data structure. In <i>5th International conference on Language Resources and Evaluation</i>.</p>
<p><a name="Pito-1994">Pito, Richard. 1994.</a> tgrepdoc&ndash;documentation for tgrep. University of Pennsylvania.</p>
<p><a name="Rohde-2005">Rohde, Douglas. 2005.</a> TGrep2 User Manual version 1.15.</p>

<br/>
<br/>

</body>
</html>
